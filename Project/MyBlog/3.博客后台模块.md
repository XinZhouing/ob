# 后台模块准备
## BlogAdminApplication 类
```java
package com.xinzhou;  
  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
@SpringBootApplication //把这个类标识为引导类(也叫启动类)  
@MapperScan("com.xinzhou.mapper") //mybatis的配置  
public class BlogAdminApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(BlogAdminApplication.class, args);  
    }  
}
```
## application.yml
```java
server:  
  port: 8989  
spring:  
  datasource:  
    url: jdbc:mysql://localhost:3306/my_blog?characterEncoding=utf-8&serverTimezone=UTC  
    username: root  
    password: 123456  
    driver-class-name: com.mysql.cj.jdbc.Driver  
  
  servlet:  
    # 文件上传  
    multipart:  
      # 单个上传文件的最大允许大小  
      max-file-size: 20MB  
      # HTTP请求中包含的所有文件的总大小的最大允许值  
      max-request-size: 20MB  
  
mybatis-plus:  
  configuration:  
    # 日志  
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  
  global-config:  
    db-config:  
      logic-delete-field: delFlag  
      logic-delete-value: 1  
      logic-not-delete-value: 0  
      id-type: auto
```
## SecurityConfig
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
//                .antMatchers("/login").anonymous()  
//                //退出登录接口，需要登录才能调用  
//                .antMatchers("/logout").authenticated()  
//                .antMatchers("/comment").authenticated()  
//                .antMatchers("/user/userInfo").authenticated()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
## JwtAuthenticationTokenFilter
```java
package com.xinzhou.filter;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import com.xinzhou.utils.WebUtils;  
import io.jsonwebtoken.Claims;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Component;  
import org.springframework.util.StringUtils;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.util.Objects;  
  
@Component  
//博客前台的登录认证过滤器(马上就要变成后台的了，这里先复制来用一下)。OncePerRequestFilter是springsecurity提供的类  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
  
        //获取 token        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)){  
            //该接口不需要token，直接放行  
            filterChain.doFilter(request,response);  
            return;  
        }  
        //解析 token 获取 userID        Claims claims = null;  
        try {  
            claims = JwtUtil.parseJWT(token);  
        } catch (Exception e) {  
            e.printStackTrace();  
            //token超时或token非法  
            //响应给前端需要重新登录，通过WebUtils工具类设置响应码  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        String userId = claims.getSubject();  
        //从 redis 中获取用户信息  
        LoginUser loginUser = redisCache.getCacheObject("login:" + userId);  
        //如果获取不到用户信息  
        if(Objects.isNull(loginUser)){  
            //说明登录过期，重新登录  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        //存入 SecurityContextHolder        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
  
        filterChain.doFilter(request,response);  
    }  
}
```
# 登录功能
需求: 后台所有功能都必须登录才能使用

|   |   |
|---|---|
|请求方式|请求路径|
|POST|/user/login|
- 请求体
```json
{
    "userName":"用户名",
    "password":"密码"
}
```
- 响应格式
```json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk"
    },
    "msg": "操作成功"
}
```
## 分析、实现
[[2.博客前台模块#登录功能]]
- SystemLoginServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.BlogUserLoginVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.BlogLoginService;  
import com.xinzhou.service.LoginService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.Authentication;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Service;  
  
import java.util.HashMap;  
import java.util.Map;  
import java.util.Objects;  
  
/**  
 * 认证，判断用户登录是否成功  
 */  
@Service  
public class SystemLoginServiceImpl implements LoginService {  
    @Autowired  
    private AuthenticationManager authenticationManager;  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    public ResponseResult login(User user) {  
        //封装登录的用户名和密码  
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());  
        //在下一行之前，封装的数据会先走UserDetailsServiceImpl实现类  
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);  
        //上面那一行会得到所有的认证用户信息authenticate。然后下一行需要判断用户认证是否通过，如果authenticate的值是null，就说明认证没有通过  
  
        //判断是否验证通过  
        if(Objects.isNull(authenticate))  
            throw new RuntimeException("用户名或密码错误");  
  
        //获取userId生成Token  
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();  
        String userId = loginUser.getUser().getId().toString();  
        String jwt = JwtUtil.createJWT(userId);  
        //把用户信息存入redis  
        redisCache.setCacheObject("login:"+userId,loginUser);  
        //将token封装 返回  
        Map<String,String> map = new HashMap<>();  
        map.put("token",jwt);  
        return ResponseResult.okResult(map);  
    }  
  
}
```
# 后台权限控制及动态路由
## 接口分析
接口设计。对应用户只能使用自己的权限所允许使用的功能

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/getInfo|需要 token 请求头|
- 响应格式如下。如果用户 id 为 1 代表管理员，roles 中只需要有 admin，permissions 中需要有所有菜单类型为 C 或者 F 的，状态为正常的，未被删除的权限
```json
{
	"code":200,
	"data":{
		"permissions":[
			"system:user:list",
            "system:role:list",
			"system:menu:list",
			"system:user:query",
			"system:user:add"
            //此次省略1000字
		],
		"roles":[
			"admin"
		],
		"user":{
			"avatar":"http://r7yxkqloa.bkt.clouddn.com/2022/03/05/75fd15587811443a9a9a771f24da458d.png",
			"email":"23412332@qq.com",
			"id":1,
			"nickName":"sg3334",
			"sex":"1"
		}
	},
	"msg":"操作成功"
}
```