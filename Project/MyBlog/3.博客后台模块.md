# 后台模块准备
## BlogAdminApplication 类
```java
package com.xinzhou;  
  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
@SpringBootApplication //把这个类标识为引导类(也叫启动类)  
@MapperScan("com.xinzhou.mapper") //mybatis的配置  
public class BlogAdminApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(BlogAdminApplication.class, args);  
    }  
}
```
## application.yml
```java
server:  
  port: 8989  
spring:  
  datasource:  
    url: jdbc:mysql://localhost:3306/my_blog?characterEncoding=utf-8&serverTimezone=UTC  
    username: root  
    password: 123456  
    driver-class-name: com.mysql.cj.jdbc.Driver  
  
  servlet:  
    # 文件上传  
    multipart:  
      # 单个上传文件的最大允许大小  
      max-file-size: 20MB  
      # HTTP请求中包含的所有文件的总大小的最大允许值  
      max-request-size: 20MB  
  
mybatis-plus:  
  configuration:  
    # 日志  
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  
  global-config:  
    db-config:  
      logic-delete-field: delFlag  
      logic-delete-value: 1  
      logic-not-delete-value: 0  
      id-type: auto
```
## SecurityConfig
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
//                .antMatchers("/login").anonymous()  
//                //退出登录接口，需要登录才能调用  
//                .antMatchers("/logout").authenticated()  
//                .antMatchers("/comment").authenticated()  
//                .antMatchers("/user/userInfo").authenticated()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
## JwtAuthenticationTokenFilter
```java
package com.xinzhou.filter;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import com.xinzhou.utils.WebUtils;  
import io.jsonwebtoken.Claims;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Component;  
import org.springframework.util.StringUtils;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.util.Objects;  
  
@Component  
//博客前台的登录认证过滤器(马上就要变成后台的了，这里先复制来用一下)。OncePerRequestFilter是springsecurity提供的类  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
  
        //获取 token        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)){  
            //该接口不需要token，直接放行  
            filterChain.doFilter(request,response);  
            return;  
        }  
        //解析 token 获取 userID        Claims claims = null;  
        try {  
            claims = JwtUtil.parseJWT(token);  
        } catch (Exception e) {  
            e.printStackTrace();  
            //token超时或token非法  
            //响应给前端需要重新登录，通过WebUtils工具类设置响应码  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        String userId = claims.getSubject();  
        //从 redis 中获取用户信息  
        LoginUser loginUser = redisCache.getCacheObject("login:" + userId);  
        //如果获取不到用户信息  
        if(Objects.isNull(loginUser)){  
            //说明登录过期，重新登录  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        //存入 SecurityContextHolder        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
  
        filterChain.doFilter(request,response);  
    }  
}
```
# 登录功能
需求: 后台所有功能都必须登录才能使用

|   |   |
|---|---|
|请求方式|请求路径|
|POST|/user/login|
- 请求体
```json
{
    "userName":"用户名",
    "password":"密码"
}
```
- 响应格式
```json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk"
    },
    "msg": "操作成功"
}
```
## 分析、实现
[[2.博客前台模块#登录功能]]
- SystemLoginServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.BlogUserLoginVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.BlogLoginService;  
import com.xinzhou.service.LoginService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.Authentication;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Service;  
  
import java.util.HashMap;  
import java.util.Map;  
import java.util.Objects;  
  
/**  
 * 认证，判断用户登录是否成功  
 */  
@Service  
public class SystemLoginServiceImpl implements LoginService {  
    @Autowired  
    private AuthenticationManager authenticationManager;  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    public ResponseResult login(User user) {  
        //封装登录的用户名和密码  
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());  
        //在下一行之前，封装的数据会先走UserDetailsServiceImpl实现类  
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);  
        //上面那一行会得到所有的认证用户信息authenticate。然后下一行需要判断用户认证是否通过，如果authenticate的值是null，就说明认证没有通过  
  
        //判断是否验证通过  
        if(Objects.isNull(authenticate))  
            throw new RuntimeException("用户名或密码错误");  
  
        //获取userId生成Token  
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();  
        String userId = loginUser.getUser().getId().toString();  
        String jwt = JwtUtil.createJWT(userId);  
        //把用户信息存入redis  
        redisCache.setCacheObject("login:"+userId,loginUser);  
        //将token封装 返回  
        Map<String,String> map = new HashMap<>();  
        map.put("token",jwt);  
        return ResponseResult.okResult(map);  
    }  
  
}
```
# 后台权限控制
## 表分析
- 权限表
![[Pasted image 20240106222905.png]]
- 角色表
![[Pasted image 20240106222945.png]]
- 用户表
![[Pasted image 20240106223016.png]]
- 角色&用户
![[Pasted image 20240106223057.png]]
- 角色&权限
![[Pasted image 20240106223129.png]]
## 接口分析
接口设计。对应用户只能使用自己的权限所允许使用的功能

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/getInfo|需要 token 请求头|
- 响应格式如下。如果用户 id 为 1 代表管理员，roles 中只需要有 admin，permissions 中需要有所有菜单类型为 C 或者 F 的，状态为正常的，未被删除的权限
```json
{
	"code":200,
	"data":{
		"permissions":[
			"system:user:list",
            "system:role:list",
			"system:menu:list",
			"system:user:query",
			"system:user:add"
            //此次省略1000字
		],
		"roles":[
			"admin"
		],
		"user":{
			"avatar":"http://r7yxkqloa.bkt.clouddn.com/2022/03/05/75fd15587811443a9a9a771f24da458d.png",
			"email":"23412332@qq.com",
			"id":1,
			"nickName":"sg3334",
			"sex":"1"
		}
	},
	"msg":"操作成功"
}
```
## 代码实现
### SystemCanstants 类修改
```java
package com.xinzhou.constants;  
  
public class SystemConstants {  
  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
      
    /**  
     *  文章是正常发布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
  
    /**  
     * 分类为正常状态  
     */  
    public static final String STATUS_NORMAL = "0";  
  
    /**  
     * 友链状态为：审核通过  
     */  
    public static final String LINK_STATUS_NORMAL = "0";  
  
    /**  
     * 评论区的某条评论是根评论  
     */  
    public static final Long COMMENT_ROOT = -1L;  
    /**  
     * 评论类型为文章评论  
     */  
    public static final String ARTICLE_COMMENT = "0";  
    /**  
     * 评论类型为友链评论  
     */  
    public static final String LINK_COMMENT = "1";  
    /**  
     * 权限类型，菜单  
     */  
    public static final String TYPE_MENU = "C";  
    /**  
     * 权限类型，按钮  
     */  
    public static final String TYPE_BUTTON = "F";  
}
```
### AdminUserInfoVo 类：负责把指定字段返回给前端
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.List;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class AdminUserInfoVo {  
    private List<String> permissions;  
  
    private List<String> roles;  
  
    private UserInfoVo user;  
}
```
### RoleServiceImpl 类：查询用户的角色信息的具体代码
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.domain.pojo.Role;  
import com.xinzhou.service.RoleService;  
import com.xinzhou.mapper.RoleMapper;  
import org.springframework.stereotype.Service;  
  
import java.util.ArrayList;  
import java.util.List;  
  
/**  
* @author 14674  
* @description 针对表【sys_role(角色信息表)】的数据库操作Service实现  
* @createDate 2024-01-06 22:48:13  
*/  
@Service  
public class RoleServiceImpl extends ServiceImpl<RoleMapper, Role>  
    implements RoleService{  
  
    @Override  
    public List<String> selectRoleKeyByUserId(Long id) {  
        //判断是否是管理员 如果是返回集合中只需要admin  
        if(id==1L){  
            ArrayList<String> roleKeys = new ArrayList<>();  
            roleKeys.add("admin");  
            return roleKeys;  
        }  
  
        //否则查询用户所具有的角色信息  
        return getBaseMapper().selectRoleKeyByUserId(id);  
    }  
}
```
### RoleMapper.xml
```xml
<!--查询用户id对应角色信息-->  
<select id="selectRoleKeyByUserId" resultType="java.lang.String">  
    SELECT  
        r.role_key    FROM        sys_user_role ur            LEFT JOIN sys_role r on r.id = ur.role_id    WHERE ur.user_id = #{userId}      and r.`status`=0      and r.del_flag =0
</select>
```
### MenuServiceImpl 类：查询用户的权限信息
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemConstants;  
import com.xinzhou.domain.pojo.Menu;  
import com.xinzhou.service.MenuService;  
import com.xinzhou.mapper.MenuMapper;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【sys_menu(菜单权限表)】的数据库操作Service实现  
* @createDate 2024-01-06 22:44:18  
*/  
@Service  
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu>  
    implements MenuService{  
  
    /**  
     * 根据用户id查询对应的权限关键字  
     * @param id  
     * @return  
     */  
    @Override  
    public List<String> selectPermsKeyByUserId(Long id) {  
  
        //如果是管理员，返回所有权限  
        if(id==1L){  
            LambdaQueryWrapper<Menu> queryWrapper = new LambdaQueryWrapper<>();  
            //查询条件是permissions中需要有所有菜单类型为C或者F的权限。  
            queryWrapper.in(Menu::getMenuType, SystemConstants.TYPE_MENU,SystemConstants.TYPE_BUTTON);  
            //查询条件是permissions中需要有状态为正常的权限。  
            queryWrapper.eq(Menu::getStatus,SystemConstants.STATUS_NORMAL);  
            List<Menu> menus = list(queryWrapper);  
            List<String> perms = menus.stream()  
                    .map(Menu::getPerms)  
                    .collect(Collectors.toList());  
            return perms;  
        }  
        //否则返回其所具有的权限  
        return getBaseMapper().selectPermsByUserId(id);  
    }  
}
```
### MenuMapper.xml
```xml
<!--查询对应权限-->  
<select id="selectPermsByUserId" resultType="java.lang.String">  
    SELECT  
        DISTINCT m.perms    FROM `sys_user_role` ur             LEFT JOIN sys_role_menu rm on ur.role_id=rm.role_id             LEFT JOIN sys_menu m on m.id = rm.menu_id    where        ur.user_id = #{userId}      and m.menu_type in ('C','F')      and m.`status`=0      and m.del_flag =0
</select>
```
### LoginController：增加了查询角色信息、权限信息的接口
```java
package com.xinzhou.controller;  
  
import com.xinzhou.annotation.SystemLog;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.AdminUserInfoVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.LoginService;  
import com.xinzhou.service.MenuService;  
import com.xinzhou.service.RoleService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.SecurityUtils;  
import org.aspectj.lang.annotation.Pointcut;  
import org.springframework.beans.BeanUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RestController;  
  
import java.util.List;  
  
@RestController  
public class LoginController {  
    @Autowired  
    private LoginService loginService;  
  
    @Autowired  
    private MenuService menuService;  
    @Autowired  
    private RoleService roleService;  
  
    @PostMapping("/user/login")  
    @SystemLog(businessName = "登录")  
    public ResponseResult login(@RequestBody User user){  
        return loginService.login(user);  
    }  
  
    @GetMapping("/getInfo")  
    @SystemLog(businessName = "查询用户权限角色信息")  
    public ResponseResult<AdminUserInfoVo> getInfo(){  
        //获取当前登录的用户  
        LoginUser loginUser = SecurityUtils.getLoginUser();  
  
        //根据用户id查询权限信息  
        List<String> perms = menuService.selectPermsKeyByUserId(loginUser.getUser().getId());  
  
        //根据用户id查询角色信息  
        List<String> roleKeyList = roleService.selectRoleKeyByUserId(loginUser.getUser().getId());  
  
        //获取用户信息  
        User user = loginUser.getUser();  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);  
  
        //封装数据返回  
        AdminUserInfoVo adminUserInfoVo = new AdminUserInfoVo(perms,roleKeyList,userInfoVo);  
        return ResponseResult.okResult(adminUserInfoVo);  
    }  
}
```
# 动态路由
## 接口分析

接口设计。后台系统需要能实现不同的用户权限可以看到不同的功能，即左侧的导航栏

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/getRouters|需要token请求头|
- 响应格式如下
	前端为了实现动态路由的效果，需要后端有接口能返回用户所能访问的菜单数据。
	注意: 返回的菜单数据需要体现父子菜单的层级关系
	如果用户 id 为 1 代表管理员，menus 中需要有所有菜单类型为 C 或者 M 的，C 表示菜单，M 表示目录，状态为正常的，未被删除的权限
```json
{
	"code":200,
	"data":{
		"menus":[
			{
				"children":[],
				"component":"content/article/write/index",
				"createTime":"2022-01-08 11:39:58",
				"icon":"build",
				"id":2023,
				"menuName":"写博文",
				"menuType":"C",
				"orderNum":"0",
				"parentId":0,
				"path":"write",
				"perms":"content:article:writer",
				"status":"0",
				"visible":"0"
			},
			{
				"children":[
					{
						"children":[],
						"component":"system/user/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"user",
						"id":100,
						"menuName":"用户管理",
						"menuType":"C",
						"orderNum":"1",
						"parentId":1,
						"path":"user",
						"perms":"system:user:list",
						"status":"0",
						"visible":"0"
					},
					{
						"children":[],
						"component":"system/role/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"peoples",
						"id":101,
						"menuName":"角色管理",
						"menuType":"C",
						"orderNum":"2",
						"parentId":1,
						"path":"role",
						"perms":"system:role:list",
						"status":"0",
						"visible":"0"
					},
					{
						"children":[],
						"component":"system/menu/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"tree-table",
						"id":102,
						"menuName":"菜单管理",
						"menuType":"C",
						"orderNum":"3",
						"parentId":1,
						"path":"menu",
						"perms":"system:menu:list",
						"status":"0",
						"visible":"0"
					}
				],
				"createTime":"2021-11-12 18:46:19",
				"icon":"system",
				"id":1,
				"menuName":"系统管理",
				"menuType":"M",
				"orderNum":"1",
				"parentId":0,
				"path":"system",
				"perms":"",
				"status":"0",
				"visible":"0"
			}
		]
	},
	"msg":"操作成功"
}
```
## 代码实现
### RoutersVo：负责把指定字段返回给前端
```java
package com.xinzhou.domain.vo;  
  
import com.xinzhou.domain.pojo.Menu;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.List;  
  
/**  
 * 动态路由返回的数据模型  
 */  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class RoutersVo {  
    private List<Menu> menus;  
}
```
### Menu 类修改：增加了 children 字段(成员变量)、增加了 Accessors(chain) = true 注解
```java
package com.xinzhou.domain.pojo;  
  
import com.baomidou.mybatisplus.annotation.IdType;  
import com.baomidou.mybatisplus.annotation.TableField;  
import com.baomidou.mybatisplus.annotation.TableId;  
import com.baomidou.mybatisplus.annotation.TableName;  
import java.io.Serializable;  
import java.util.Date;  
import java.util.List;  
  
import lombok.Data;  
import lombok.experimental.Accessors;  
  
/**  
 * 菜单权限表  
 * @TableName sys_menu  
 */@TableName(value ="sys_menu")  
@Data  
@Accessors(chain = true)//set方法返回值会修改为Menu，允许链式编程  
public class Menu implements Serializable {  
    /**  
     * 菜单ID  
     */    @TableId(type = IdType.AUTO)  
    private Long id;  
  
    /**  
     * 菜单名称  
     */  
    private String menuName;  
  
    /**  
     * 父菜单ID  
     */    private Long parentId;  
  
    /**  
     * 显示顺序  
     */  
    private Integer orderNum;  
  
    /**  
     * 路由地址  
     */  
    private String path;  
  
    /**  
     * 组件路径  
     */  
    private String component;  
  
    /**  
     * 是否为外链（0是 1否）  
     */  
    private Integer isFrame;  
  
    /**  
     * 菜单类型（M目录 C菜单 F按钮）  
     */  
    private String menuType;  
  
    /**  
     * 菜单状态（0显示 1隐藏）  
     */  
    private String visible;  
  
    /**  
     * 菜单状态（0正常 1停用）  
     */  
    private String status;  
  
    /**  
     * 权限标识  
     */  
    private String perms;  
  
    /**  
     * 菜单图标  
     */  
    private String icon;  
  
    /**  
     * 创建者  
     */  
    private Long createBy;  
  
    /**  
     * 创建时间  
     */  
    private Date createTime;  
  
    /**  
     * 更新者  
     */  
    private Long updateBy;  
  
    /**  
     * 更新时间  
     */  
    private Date updateTime;  
  
    /**  
     * 备注  
     */  
    private String remark;  
  
    /**  
     *     */  
    private String delFlag;  
  
    /**  
     * 返回动态路由的子路由  
     */  
    @TableField(exist = false)  
    private List<Menu> children;  
  
    @TableField(exist = false)  
    private static final long serialVersionUID = 1L;  
}
```
### MenuServiceImpl 类修改：增加了查询用户的路由信息(权限菜单)的具体代码
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemConstants;  
import com.xinzhou.domain.pojo.Menu;  
import com.xinzhou.service.MenuService;  
import com.xinzhou.mapper.MenuMapper;  
import com.xinzhou.utils.SecurityUtils;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【sys_menu(菜单权限表)】的数据库操作Service实现  
* @createDate 2024-01-06 22:44:18  
*/  
@Service  
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu>  
    implements MenuService{  
  
    /**  
     * 根据用户id查询对应的权限关键字  
     * @param id  
     * @return  
     */  
    @Override  
    public List<String> selectPermsKeyByUserId(Long id) {  
  
        //如果是管理员，返回所有权限  
        if(SecurityUtils.isAdmin()){  
            LambdaQueryWrapper<Menu> queryWrapper = new LambdaQueryWrapper<>();  
            //查询条件是permissions中需要有所有菜单类型为C或者F的权限。  
            queryWrapper.in(Menu::getMenuType, SystemConstants.TYPE_MENU,SystemConstants.TYPE_BUTTON);  
            //查询条件是permissions中需要有状态为正常的权限。  
            queryWrapper.eq(Menu::getStatus,SystemConstants.STATUS_NORMAL);  
            List<Menu> menus = list(queryWrapper);  
            List<String> perms = menus.stream()  
                    .map(Menu::getPerms)  
                    .collect(Collectors.toList());  
            return perms;  
        }  
        //否则返回其所具有的权限  
        return getBaseMapper().selectPermsByUserId(id);  
    }  
  
    /**  
     * 动态路由  
     * @param userId  
     * @return  
     */  
    @Override  
    public List<Menu> selectRouterMenuTreeByUserId(Long userId) {  
        MenuMapper menuMapper = getBaseMapper();  
        List<Menu> menus = null;  
        //判断是否是管理员  
        if(SecurityUtils.isAdmin()){  
            //如果是 返回所有符合要求的menu  
            menus = menuMapper.selectAllRouterMenu();  
        }else {  
            //否则 返回当前用户所具有的menu  
            menus = menuMapper.selectRouterMenuTreeByUserId(userId);  
        }  
        //构建成tree，也就是子父菜单树，有层级关系  
        //思路:先找出第一层的菜单，然后再找子菜单(也就是第二层)，把子菜单的结果赋值给Menu类的children字段  
        List<Menu> menuTree = buliderMenuTree(menus,0L);  
  
        return menuTree;  
    }  
  
    /**  
     * 用于把List集合里面的数据构建成tree，也就是子父菜单树，有层级关系  
     * @param menus  
     * @param parentId  
     * @return  
     */  
    private List<Menu> buliderMenuTree(List<Menu> menus, Long parentId) {  
        List<Menu> menuTree = menus.stream()  
                .filter(menu -> menu.getParentId().equals(parentId))  
                //getChildren是我们在下面写的方法，用于获取子菜单的List集合  
                .map(menu -> menu.setChildren(getChildren(menu, menus)))  
                .collect(Collectors.toList());  
        return menuTree;  
    }  
  
    /**  
     * 获取传入参数的子menu集合  
     *  
     * @param menu  
     * @param menus  
     * @return  
     */  
    private List<Menu> getChildren(Menu menu, List<Menu> menus) {  
        List<Menu> childrenList = menus.stream()  
                .filter(m -> m.getParentId().equals(menu.getId()))  
                //如果有三层菜单的话，也就是子菜单的子菜单，我们就用下面那行递归(自己调用自己)来处理  
                .map(m -> m.setChildren(getChildren(m,menus)))  
                .collect(Collectors.toList());  
        return childrenList;  
    }  
}
```
### MenuMapper 接口修改：增加了2个(一个查超级管理员，另一个查普通用户)查询权限菜单的接口
```java
package com.xinzhou.mapper;  
  
import com.xinzhou.domain.pojo.Menu;  
import com.baomidou.mybatisplus.core.mapper.BaseMapper;  
  
import java.util.List;  
  
/**  
* @author 14674  
* @description 针对表【sys_menu(菜单权限表)】的数据库操作Mapper  
* @createDate 2024-01-06 22:44:18  
* @Entity com.xinzhou.domain.pojo.Menu  
*/  
public interface MenuMapper extends BaseMapper<Menu> {  
    //查询普通用户的权限信息  
    List<String> selectPermsByUserId(Long userId);  
  
    //查询超级管理员的路由信息(权限菜单)  
    List<Menu> selectAllRouterMenu();  
    //查询普通用户的路由信息(权限菜单)  
    List<Menu> selectRouterMenuTreeByUserId(Long userId);  
}
```
### MenuMapper.xml 
```xml
<?xml version="1.0" encoding="UTF-8"?>  
<!DOCTYPE mapper  
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
<mapper namespace="com.xinzhou.mapper.MenuMapper">  
  
    <resultMap id="BaseResultMap" type="com.xinzhou.domain.pojo.Menu">  
            <id property="id" column="id" jdbcType="BIGINT"/>  
            <result property="menuName" column="menu_name" jdbcType="VARCHAR"/>  
            <result property="parentId" column="parent_id" jdbcType="BIGINT"/>  
            <result property="orderNum" column="order_num" jdbcType="INTEGER"/>  
            <result property="path" column="path" jdbcType="VARCHAR"/>  
            <result property="component" column="component" jdbcType="VARCHAR"/>  
            <result property="isFrame" column="is_frame" jdbcType="INTEGER"/>  
            <result property="menuType" column="menu_type" jdbcType="CHAR"/>  
            <result property="visible" column="visible" jdbcType="CHAR"/>  
            <result property="status" column="status" jdbcType="CHAR"/>  
            <result property="perms" column="perms" jdbcType="VARCHAR"/>  
            <result property="icon" column="icon" jdbcType="VARCHAR"/>  
            <result property="createBy" column="create_by" jdbcType="BIGINT"/>  
            <result property="createTime" column="create_time" jdbcType="TIMESTAMP"/>  
            <result property="updateBy" column="update_by" jdbcType="BIGINT"/>  
            <result property="updateTime" column="update_time" jdbcType="TIMESTAMP"/>  
            <result property="remark" column="remark" jdbcType="VARCHAR"/>  
            <result property="delFlag" column="del_flag" jdbcType="CHAR"/>  
    </resultMap>  
    <sql id="Base_Column_List">  
        id,menu_name,parent_id,  
        order_num,path,component,        is_frame,menu_type,visible,        status,perms,icon,        create_by,create_time,update_by,        update_time,remark,del_flag    </sql>  
  
    <!--查询对应权限-->  
    <select id="selectPermsByUserId" resultType="java.lang.String">  
        SELECT  
            DISTINCT m.perms        FROM `sys_user_role` ur                 LEFT JOIN sys_role_menu rm on ur.role_id=rm.role_id                 LEFT JOIN sys_menu m on m.id = rm.menu_id        where            ur.user_id = #{userId}          and m.menu_type in ('C','F')          and m.`status`=0          and m.del_flag =0    </select>  
  
    <!--动态路由：查询所有菜单-->  
    <select id="selectAllRouterMenu" resultType="com.xinzhou.domain.pojo.Menu">  
        SELECT  
            DISTINCT <include refid="Base_Column_List"></include>  
        FROM sys_menu  
        where            menu_type in ('C','M')          and `status`=0          and del_flag =0        ORDER BY            parent_id,order_num    </select>  
  
    <select id="selectRouterMenuTreeByUserId" resultType="com.xinzhou.domain.pojo.Menu">  
        SELECT  
        DISTINCT <include refid="Base_Column_List"></include>  
        FROM `sys_user_role` ur  
        LEFT JOIN sys_role_menu rm on ur.role_id=rm.role_id        LEFT JOIN sys_menu m on m.id = rm.menu_id        where        ur.user_id = #{userId}        and m.menu_type in ('C','M')        and m.`status`=0        and m.del_flag =0        ORDER BY        m.parent_id,m.order_num    </select>  
</mapper>
```
### LoginController 
```java
package com.xinzhou.controller;  
  
import com.xinzhou.annotation.SystemLog;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.Menu;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.AdminUserInfoVo;  
import com.xinzhou.domain.vo.RoutersVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.LoginService;  
import com.xinzhou.service.MenuService;  
import com.xinzhou.service.RoleService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.SecurityUtils;  
import org.aspectj.lang.annotation.Pointcut;  
import org.springframework.beans.BeanUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RestController;  
  
import java.util.List;  
  
@RestController  
public class LoginController {  
    @Autowired  
    private LoginService loginService;  
  
    @Autowired  
    private MenuService menuService;  
    @Autowired  
    private RoleService roleService;  
  
    @PostMapping("/user/login")  
    @SystemLog(businessName = "登录")  
    public ResponseResult login(@RequestBody User user){  
        return loginService.login(user);  
    }  
  
    @GetMapping("/getInfo")  
    @SystemLog(businessName = "查询用户权限、角色信息")  
    public ResponseResult<AdminUserInfoVo> getInfo(){  
        //获取当前登录的用户  
        LoginUser loginUser = SecurityUtils.getLoginUser();  
  
        //根据用户id查询权限信息  
        List<String> perms = menuService.selectPermsKeyByUserId(loginUser.getUser().getId());  
  
        //根据用户id查询角色信息  
        List<String> roleKeyList = roleService.selectRoleKeyByUserId(loginUser.getUser().getId());  
  
        //获取用户信息  
        User user = loginUser.getUser();  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);  
  
        //封装数据返回  
        AdminUserInfoVo adminUserInfoVo = new AdminUserInfoVo(perms,roleKeyList,userInfoVo);  
        return ResponseResult.okResult(adminUserInfoVo);  
    }  
  
    @GetMapping("/getRouters")  
    @SystemLog(businessName = "查询动态路由")  
    public ResponseResult<RoutersVo> getRouters(){  
        //获取当前登录的用户id  
        Long userId = SecurityUtils.getUserId();  
  
        //查询menu 结果是tree的形式  
        List<Menu> menus = menuService.selectRouterMenuTreeByUserId(userId);  
  
        //封装数据返回  
        return ResponseResult.okResult(new RoutersVo(menus));  
    }  
}
```
# 退出登录
## 接口分析
删除redis中的用户信息

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/user/logout|需要 token 请求头|
- 响应格式:
```json
{
    "code": 200,
    "msg": "操作成功"
}
```
## 代码实现
### SystemLoginServiceImpl 
```java
/**  
 * 退出登录  
 * @return  
 */  
@Override  
public ResponseResult logout() {  
    //获取当前登录的用户id  
    Long userId = SecurityUtils.getUserId();  
    //删除redis中对应的值  
    redisCache.deleteObject("login:"+userId);  
    return ResponseResult.okResult();  
}
```
# 标签列表
## 查询标签
### 接口分析
注意：不能把删除了的标签查询出来。除了可以根据标签名查询文章，后期还要添加根据备注名查询文章

|   |   |
|---|---|
|请求方式|请求路径|
|Get|content/tag/list|
```txt
Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

name：标签名

remark：备注
```
- 响应
```json
{
	"code":200,
	"data":{
		"rows":[
			{
				"id":4,
				"name":"Java",
				"remark":"sdad"
			}
		],
		"total":1
	},
	"msg":"操作成功"
}
```
### 代码实现
- TagServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.dto.TagListDto;  
import com.xinzhou.domain.pojo.Tag;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.service.TagService;  
import com.xinzhou.mapper.TagMapper;  
import org.springframework.stereotype.Service;  
import org.springframework.util.StringUtils;  
  
/**  
* @author 14674  
* @description 针对表【tag(标签)】的数据库操作Service实现  
* @createDate 2024-01-06 11:26:41  
*/  
@Service  
public class TagServiceImpl extends ServiceImpl<TagMapper, Tag>  
    implements TagService{  
  
    /**  
     * 查询标签  
     * @param pageNum  
     * @param pageSize  
     * @param tagListDto  
     * @return  
     */  
    @Override  
    public ResponseResult<PageVo> pageTagList(Integer pageNum, Integer pageSize, TagListDto tagListDto) {  
  
        //分页查询  
        LambdaQueryWrapper<Tag> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(StringUtils.hasText(tagListDto.getName()),Tag::getName,tagListDto.getName());  
        queryWrapper.eq(StringUtils.hasText(tagListDto.getRemark()),Tag::getRemark,tagListDto.getRemark());  
  
        Page<Tag> page = new Page<Tag>();  
        page.setCurrent(pageNum);  
        page.setSize(pageSize);  
        page(page,queryWrapper);  
        //封装数据返回  
        return ResponseResult.okResult(new PageVo(page.getRecords(),page.getTotal()));  
    }  
}
```
## 新增标签
### 接口分析
点击标签管理的新增按钮可以实现新增标签的功能

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/content/tag|需要 token 请求头|
- 请求体格式:
```json
{"name":"标签名","remark":"标签的备注名"}
```
- 响应格式：
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
```java
@PostMapping  
@SystemLog(businessName = "添加标签")  
public ResponseResult addTag(@RequestBody AddEditTagDto addEditTagDto){  
    Tag tag = BeanCopyUtils.copyBean(addEditTagDto, Tag.class);  
    tagService.save(tag);  
    return ResponseResult.okResult();  
}
```


## 删除标签
### 接口分析
例如 content/tag/6 代表删除 id 为6的标签数据。删除后在列表中是否查看不到该条数据，但是数据库中该条数据还是存在的，只是修改了逻辑删除字段的值

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|DELETE|/content/tag/{id}|需要 token 请求头|
- 响应
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
- TagController
```java
@DeleteMapping("/{id}")  
@SystemLog(businessName = "删除标签")  
public ResponseResult delete(@PathVariable(value = "id") Long id){  
    //逻辑删除  
    tagService.removeById(id);  
    return ResponseResult.okResult();  
}
```
- TagServiceImpl 
```java
/**  
 * 删除标签  
 * @param id  
 * @return  
 */  
@Override  
public int removeById(Long id) {  
    return tagMapper.myUpdateById(id,1);  
}
```

## 修改标签
### 接口分析
①根据标签 id 来获取某一条标签的信息，当用户点击修改按钮时触发，展示在弹框里面。例如：content/tag/6 代表获取 id 为6的标签数据

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/content/tag/{id}|需要 token 请求头|
- 响应格式： 
```json
{
	"code":200,
	"data":{
        "id":4,
        "name":"标签名",
        "remark":"标签的备注名"
	},
	"msg":"操作成功"
}
```
②修改标签接口:

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|PUT|/content/tag|需要 token 请求头|
- 请求体格式：
```json
{"id":7,"name":"标签名","remark":"标签的备注名"}
```
- 响应
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
```java
@GetMapping("/{id}")  
@SystemLog(businessName = "查询标签详情")  
public ResponseResult<TagVo> get(@PathVariable(value = "id") Long id){  
  
    Tag tag = tagService.getById(id);  
    TagVo tagVo = BeanCopyUtils.copyBean(tag, TagVo.class);  
    return ResponseResult.okResult(tagVo);  
}  
@PutMapping  
@SystemLog(businessName = "修改标签")  
public ResponseResult edit(@RequestBody AddEditTagDto addEditTagDto){  
    Tag tag = BeanCopyUtils.copyBean(addEditTagDto, Tag.class);  
    tagService.updateById(tag);  
    return ResponseResult.okResult();  
}
```
# 新增博文
## 接口分析
### 查询所有分类接口 
- 请求方式如下:

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET |/content/category/listAllCategory |需要 token 请求头|
- 参数：无
- 响应：
```json
{
	"code":200,
	"data":[
		{
			"discription":"wsd",
			"id":1,
			"name":"java"
		}
	],
	"msg":"操作成功"
}
```
### 查询所有标签接口
- 请求方式如下:

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET |/content/tag/listAllTag |需要 token 请求头|
- 参数：无
- 响应
```json
{
	"code":200,
	"data":[
		{
			"id":1,
			"name":"java"
		}
	],
	"msg":"操作成功"
}
```
### 上传图片接口

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST |/upload |需要 token 请求头|
- 参数：img，值为上传的文件
- 请求头：
Content-Type: multipar/form-data;
- 响应
```json
{
	"code":200,
	"data":"文件访问链接",
	"msg":"操作成功"
}
```
### 新增博文接口
- 请求方式如下:

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/content/article|需要 token 请求头|
- 请求体格式：
```json
{
    "title":"测试新增博文",
    "thumbnail":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/21/4ceebc07e7484beba732f12b0d2c43a9.png",
    "isTop":"0",
    "isComment":"0",
    "content":"# 一级标题\n## 二级标题\n![Snipaste_20220228_224837.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/21/c3af554d4a0f4935b4073533a4c26ee8.png)\n正文",
    "tags":[
        1,
        4
    ],
    "categoryId":1,
    "summary":"哈哈",
    "status":"1"
}
```
- 响应
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
### 查询所有分类接口
#### CategoryVo
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class CategoryVo {  
  
    private String description;  
    private Long id;  
    private String name;  
}
```
#### CategoryServiceImpl
```java
/**  
 * 查询所有分类  
 * @return  
 */  
@Override  
public ResponseResult<CategoryVo> listAllCategory() {  
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Category::getStatus,SystemConstants.STATUS_NORMAL);  
    List<Category> list = list(queryWrapper);  
    List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(list, CategoryVo.class);  
    return ResponseResult.okResult(categoryVos);  
}
```
#### admin 工程的 controller 目录新建 CategoryController 类
```java
package com.xinzhou.controller;  
  
import com.xinzhou.annotation.SystemLog;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.service.CategoryService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import java.util.List;  
  
@RestController  
@RequestMapping("/content/category")  
public class CategoryController {  
  
    @Autowired  
    private CategoryService categoryService;  
  
    @GetMapping("/listAllCategory")  
    @SystemLog(businessName = "查询所有分类")  
    public ResponseResult<CategoryVo> listAllCategory(){  
        return categoryService.listAllCategory();  
    }  
  
}
```
### 查询所有标签接口 
#### TagListDto 
```java
package com.xinzhou.domain.dto;  
  
import io.swagger.annotations.ApiModel;  
import lombok.Data;  
  
@Data  
@ApiModel(description = "添加标签dto")  
public class TagListDto {  
  
    private String name;  
    private String remark;  
}
```
#### TagServiceImpl
```java
/**  
 * 查询所有标签  
 * @return  
 */  
@Override  
public ResponseResult<TagVo> listAllTag() {  
    LambdaQueryWrapper<Tag> queryWrapper = new LambdaQueryWrapper<>();  
    //select:定义查询的字段  
    queryWrapper.select(Tag::getId,Tag::getName);  
    List<Tag> list = list(queryWrapper);  
    List<TagVo> tagVos = BeanCopyUtils.copyBeanList(list, TagVo.class);  
    return ResponseResult.okResult(tagVos);  
}
```
### 上传图片
#### admin 工程的 application.yml 修改:增加了 OSS 的相关配置
```yaml
server:  
  port: 8989  
spring:  
  datasource:  
    url: jdbc:mysql://localhost:3306/my_blog?characterEncoding=utf-8&serverTimezone=UTC  
    username: root  
    password: 123456  
    driver-class-name: com.mysql.cj.jdbc.Driver  
  
  servlet:  
    # 文件上传  
    multipart:  
      # 单个上传文件的最大允许大小  
      max-file-size: 20MB  
      # HTTP请求中包含的所有文件的总大小的最大允许值  
      max-request-size: 20MB  
  
mybatis-plus:  
  configuration:  
    # 日志  
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  
  global-config:  
    db-config:  
      logic-delete-field: delFlag  
      logic-delete-value: 1  
      logic-not-delete-value: 0  
      id-type: auto  
  
# oss AK、SK配置  
oss:  
  accessKey: Ub9EoLlHd1CXNnqr8bW8Af40gKuhlGEtl8xP35Gw  
  secretKey: GQ98e5c0Xa1H7FzwkwmIgoTS3RpCA5QJFe0bdEx5  
  bucket: xinzhou-blog
```
#### admin 工程的 controller 目录新建 UploadController 类
```java
package com.xinzhou.controller;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.service.UploadService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestParam;  
import org.springframework.web.bind.annotation.RestController;  
import org.springframework.web.multipart.MultipartFile;  
  
import java.io.IOException;  
  
/**  
 * 上传图片  
 */  
@RestController  
public class UploadController {  
    @Autowired  
    private UploadService uploadService;  
    @PostMapping("/upload")  
    public ResponseResult uploadImg(@RequestParam("img") MultipartFile multipartFile){  
        try {  
  
            return uploadService.uploadImg(multipartFile);  
        }catch (Exception e){  
            e.printStackTrace();  
            throw new RuntimeException("文件上传失败");  
        }  
    }  
}
```
### 新增博文
#### 生成 ArticleTag 实体、ArticleTagService、ArticleTagServiceImpl...
#### 新建 AddArticleDto 类:用来接受前端传过来的参数，最重要的是 tags 属性
```java
package com.xinzhou.domain.dto;  
  
import com.baomidou.mybatisplus.annotation.IdType;  
import com.baomidou.mybatisplus.annotation.TableField;  
import com.baomidou.mybatisplus.annotation.TableId;  
import io.swagger.annotations.ApiModel;  
import lombok.Data;  
  
import java.util.Date;  
import java.util.List;  
  
@Data  
@ApiModel(description = "发布博文dto")  
public class AddArticleDto {  
  
    private Long id;  
  
    /**  
     * 标题  
     */  
    private String title;  
  
    /**  
     * 文章内容  
     */  
    private String content;  
  
    /**  
     * 文章摘要  
     */  
    private String summary;  
  
    /**  
     * 所属分类id  
     */    private Long categoryId;  
  
  
    /**  
     * 缩略图  
     */  
    private String thumbnail;  
  
    /**  
     * 是否置顶（0否，1是）  
     */  
    private String isTop;  
  
    /**  
     * 状态（0已发布，1草稿）  
     */  
    private String status;  
  
    /**  
     * 访问量  
     */  
    private Long viewCount;  
  
    /**  
     * 是否允许评论 1是，0否  
     */  
    private String isComment;  
  
    private List<Long> tags;  
}
```
#### ArticleServiceImpl 类修改:增加了写博客文章接口的具体代码实现
```java
/**  
 * 发布博文  
 * @param addArticleDto  
 * @return  
 */  
@Override  
@Transactional//开启事务  
public ResponseResult add(AddArticleDto addArticleDto) {  
  
    //添加 博客  
    Article article = BeanCopyUtils.copyBean(addArticleDto, Article.class);  
    save(article);  
  
    List<ArticleTag> articleTags = addArticleDto.getTags().stream()  
            .map(tagId -> new ArticleTag(article.getId(), tagId))  
            .collect(Collectors.toList());  
  
    //添加博客和标签的关联关系  
    articleTagService.saveBatch(articleTags);  
    return ResponseResult.okResult();  
}
```
# 导出分类（EasyExcel）
## 接口分析
- 使用 easyExcel 实现 Excel 的导出操作
- 官方地址: https://github.com/alibaba/easyexcel
- 快速开始: https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1
在分类管理中点击导出按钮可以把所有的分类导出到 Excel 文件中

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/content/category/export|需要 token 请求头|
- 响应格式： 成功的话直接导出一个 Excel 文件
- 失败的话响应格式如下： 
```json
{
	"code":500,
	"msg":"出现错误"
}
```
## 代码实现
### 导入依赖
```xml
<!--easyExcel的依赖-->
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>easyexcel</artifactId>
</dependency>
```
### 工具类方法修改
- [[WebUtils]] 
```java
//easyExcel文件导出,设置响应头  
public static void setDownLoadHeader(String filename, HttpServletResponse response) throws UnsupportedEncodingException {  
    response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");  
    response.setCharacterEncoding("utf-8");  
    String fname= URLEncoder.encode(filename,"UTF-8").replaceAll("\\+", "%20");  
    response.setHeader("Content-disposition","attachment; filename="+fname);  
}
```
### 新建 ExcelCategoryVo 类
```java
package com.xinzhou.domain.vo;  
  
import com.alibaba.excel.annotation.ExcelProperty;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class ExcelCategoryVo {  
  
    private Long id;  
    @ExcelProperty("分类名")  
    private String name;  
    @ExcelProperty("描述名")  
    private String description;  
    /**  
     * 状态0:正常,1禁用  
     */  
    @ExcelProperty("状态0:正常,1禁用")  
    private String status;  
  
}
```
### CategoryController 
```java
package com.xinzhou.controller;  
  
import com.alibaba.excel.EasyExcel;  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.annotation.SystemLog;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Category;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.domain.vo.ExcelCategoryVo;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.service.CategoryService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import javax.servlet.http.HttpServletResponse;  
import java.io.UnsupportedEncodingException;  
import java.util.List;  
  
@RestController  
@RequestMapping("/content/category")  
public class CategoryController {  
  
    @Autowired  
    private CategoryService categoryService;  
  
    @GetMapping("/listAllCategory")  
    @SystemLog(businessName = "查询所有分类")  
    public ResponseResult<CategoryVo> listAllCategory(){  
        return categoryService.listAllCategory();  
    }  
  
    @GetMapping("/export")  
    @SystemLog(businessName = "导出分类")  
    public void export(HttpServletResponse response){  
        try {  
            //设置下载文件的请求头  
            WebUtils.setDownLoadHeader("分类.xlsx",response);  
            //获取需要导出的数据  
            List<Category> categories = categoryService.list();  
            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtils.copyBeanList(categories, ExcelCategoryVo.class);  
  
            //把数据写入到Excel中，也就是把ExcelCategoryVo实体类的字段作为Excel表格的列头  
            //sheet方法里面的字符串是Excel表格左下角工作簿的名字  
            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class).autoCloseStream(Boolean.FALSE).sheet("文章分类")  
                    .doWrite(excelCategoryVos);  
  
        } catch (Exception e) {  
            //如果出现异常也要响应json  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR);  
            //WebUtils是我们在framework工程写的类，里面的renderString方法是将json字符串写入到请求体，然后返回给前端  
            WebUtils.renderString(response, JSON.toJSONString(result));  
        }  
  
  
    }  
}
```
### 遇到的问题
- 在导出 Excel 上加上打印日志注解 `@SystemLog(businessName = "导出分类") ` 会出现异常
- 解决
在 LogAspect 类中打印参数时进行过滤
```java
//过滤部分参数，否则在导出excel时会出现异常  
Object[] args = joinPoint.getArgs();  
List<Object> arguments = Arrays.stream(args)  
        .filter(arg -> !(arg instanceof ServletRequest || arg instanceof ServletResponse || arg instanceof MultipartFile))  
        .collect(Collectors.toList());  
// 打印请求入参,JSON.toJSONString是FastJson提供的工具方法，能把数组转成JSON  
log.info("传入参数   : {}", JSON.toJSONString(arguments));
```
# 权限控制
## admin 工程的 SecurityConfig 修改
增加 `@EnableGlobalMethodSecurity(prePostEnabled = true)` 注解开启权限控制
## LoginUser 类修改:增加了权限信息集合的成员变量
```java
package com.xinzhou.domain.pojo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
import org.springframework.security.core.GrantedAuthority;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Collection;  
import java.util.List;  
  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
//UserDetails是SpringSecurity官方提供的接口  
public class LoginUser implements UserDetails {  
    private User user;  
  
    private List<String> permission;  
  
    /**  
     * 用于返回权限信息。现在我们正在实现'认证'，'权限'后面才用得到。所以返回null即可  
     * 当要查询用户信息的时候，我们不能单纯返回null，要重写这个方法，作用是返回权限信息  
     * @return  
     */  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return null;  
    }  
  
    /**  
     * 用于获取用户密码。由于使用的实体类是User，所以获取的是数据库的用户密码  
     * @return  
     */  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    /**  
     * 用于获取用户名。由于使用的实体类是User，所以获取的是数据库的用户名  
     * @return  
     */  
    @Override  
    public String getUsername() {  
        return user.getUserName();  
    }  
  
    /**  
     * 判断登录状态是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isAccountNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断账号是否被锁定。把这个改成true，表示未锁定  
     * @return  
     */  
    @Override  
    public boolean isAccountNonLocked() {  
        return true;  
    }  
  
    /**  
     * 判断登录凭证是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断用户是否可用。把这个改成true，表示可用状态  
     * @return  
     */  
    @Override  
    public boolean isEnabled() {  
        return true;  
    }  
}
```
## UserDetailsServiceImpl 类修改:增加了权限信息的相关实现
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.xinzhou.constants.SystemConstants;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.mapper.MenuMapper;  
import com.xinzhou.mapper.UserMapper;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.core.userdetails.UsernameNotFoundException;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Objects;  
  
/**  
 * 当BlogLoginServiceImpl类封装好登录的用户名和密码之后，就会传到当前这个实现类  
 */  
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private UserMapper userMapper;  
    @Autowired  
    private MenuMapper menuMapper;  
    @Override  
    //在这里之前，我们已经拿到了登录的用户名和密码。UserDetails是SpringSecurity官方提供的接口  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
  
        //根据用户名查询用户信息  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getUserName,username);  
        User user = userMapper.selectOne(queryWrapper);  
        //判断是否查询到用户 如果没查询到则抛出异常  
        if (Objects.isNull(user))  
            throw new RuntimeException("用户不存在");//后期会对异常进行统一处理  
  
        //如果是后台用户需要查询权限封装  
        if(SystemConstants.IS_ADMIN.equals(user.getType())){  
            List<String> list = menuMapper.selectPermsByUserId(user.getId());  
            return new LoginUser(user,list);  
        }  
  
        //返回用户信息  
        return new LoginUser(user,null);  
    }  
}
```
## 在 framework 工程的 service 目录创建 impl.PermissionService 类
```java
package com.xinzhou.service.impl;  
  
import com.xinzhou.utils.SecurityUtils;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
  
/**  
 * 自定义权限控制方法  
 */  
@Service("ps")  
public class PermissionService {  
    /**  
     * 判断当前用户是否具有permission  
     * @param permission 要判断的权限  
     * @return  
     */  
    public boolean hasPermission(String permission){  
  
        //如果是超级管理员 直接返回true  
        if(SecurityUtils.isAdmin()){  
            return true;  
        }  
        //否则 获取当前登录用户所具有的权限列表 并判断是否存在permission  
        List<String> permissions = SecurityUtils.getLoginUser().getPermission();  
        return permissions.contains(permission);  
    }  
}
```
## CategoryController 类修改：在 export 方法的上面添加了@PreAuthorize 注解
```java
package com.xinzhou.controller;  
  
import com.alibaba.excel.EasyExcel;  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.annotation.SystemLog;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Category;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.domain.vo.ExcelCategoryVo;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.service.CategoryService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.access.prepost.PreAuthorize;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
import javax.servlet.http.HttpServletResponse;  
import java.io.UnsupportedEncodingException;  
import java.util.List;  
  
@RestController  
@RequestMapping("/content/category")  
public class CategoryController {  
  
    @Autowired  
    private CategoryService categoryService;  
  
    @GetMapping("/listAllCategory")  
    @SystemLog(businessName = "查询所有分类")  
    public ResponseResult<CategoryVo> listAllCategory(){  
        return categoryService.listAllCategory();  
    }  
  
    @PreAuthorize("@ps.hasPermission('content:category:export')")//权限控制，ps是我们自定义PermissionService类的bean名称，也可以使用SpringSecurity的hasAuthority方法校验  
    @GetMapping("/export")  
    @SystemLog(businessName = "导出分类")  
    public void export(HttpServletResponse response){  
        try {  
            //设置下载文件的请求头  
            WebUtils.setDownLoadHeader("分类.xlsx",response);  
            //获取需要导出的数据  
            List<Category> categories = categoryService.list();  
            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtils.copyBeanList(categories, ExcelCategoryVo.class);  
  
            //把数据写入到Excel中，也就是把ExcelCategoryVo实体类的字段作为Excel表格的列头  
            //sheet方法里面的字符串是Excel表格左下角工作簿的名字  
            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class).autoCloseStream(Boolean.FALSE).sheet("文章分类")  
                    .doWrite(excelCategoryVos);  
  
        } catch (Exception e) {  
            //如果出现异常也要响应json  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR);  
            //WebUtils是我们在framework工程写的类，里面的renderString方法是将json字符串写入到请求体，然后返回给前端  
            WebUtils.renderString(response, JSON.toJSONString(result));  
        }  
  
  
    }  
}
```
## 修改 GlobalExceptionHandler：增加了处理 springsecurity 的权限异常处理
```java
package com.xinzhou.handler.exception;  
  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import lombok.extern.slf4j.Slf4j;  
  
import org.springframework.security.access.AccessDeniedException;  
import org.springframework.web.bind.annotation.ExceptionHandler;  
import org.springframework.web.bind.annotation.RestControllerAdvice;  
  
/**  
 * @author 14674  
 * @date 2023/7/23 0023 22:03  
 *///@ControllerAdvice //对controller层的增强  
//@ResponseBody  
  
//或者用下面一个注解代替上面的两个注解  
@RestControllerAdvice  
  
//使用Lombok提供的Slf4j注解，实现日志功能  
@Slf4j  
  
//全局异常处理。最终都会在这个类进行处理异常  
public class GlobalExceptionHandler {  
  
    //SystemException是我们写的类。用户登录的异常交给这里处理  
    @ExceptionHandler(SystemException.class)  
    public ResponseResult systemExceptionHandler(SystemException e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult是我们写的类  
        return ResponseResult.errorResult(e.getCode(),e.getMsg());  
    }  
  
    // 处理SpringSecurity的权限异常  
    @ExceptionHandler(AccessDeniedException.class)  
    public ResponseResult handleAccessDeniedException(AccessDeniedException e) {  
        return ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH.getCode(),e.getMessage());//枚举值是500  
    }  
  
    //其它异常交给这里处理  
    @ExceptionHandler(Exception.class)  
    public ResponseResult exceptionHandler(Exception e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult、AppHttpCodeEnum是我们写的类  
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());//枚举值是500  
    }  
}
```
# 分类列表
## 查询分类
### 表分析
![[1704727149345.png]]
### 接口分析
查询分类列表的信息  

|   |   |
|---|---|
|请求方式|请求地址|
|GET|/content/category/list|
- Query 格式请求参数如下:
```txt
pageNum:页码
pageSize:每页条数
```
- 响应
```json
{
	"code":200,
	"data":{
		"rows":[
			{
				"id":1,
				"name":"分类名",
				"status":"0",
                "description":"分类描述",
                "delFlag":"0",
                "pid":"-1",
			}
		],
		"total":1
	},
	"msg":"操作成功"
}
```
### 代码实现
- CategoryServiceImpl
```java
/**  
 * 分页查询分类  
 * @param pageNum  
 * @param pageSize  
 * @return  
 */  
@Override  
public ResponseResult list(Category category,Integer pageNum, Integer pageSize) {  
    //查询正常的分类  
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.like(StringUtils.hasText(category.getName()),Category::getName,category.getName());  
    queryWrapper.eq(Objects.nonNull(category.getStatus()),Category::getStatus,category.getStatus());  
  
    //转换从CategoryVo封装并返回  
    Page<Category> page = new Page<>(pageNum,pageSize);  
    page = page(page,queryWrapper);  
    List<CategoryListVo> categoryListVos = BeanCopyUtils.copyBeanList(page.getRecords(), CategoryListVo.class);  
  
    return ResponseResult.okResult(new PageVo(categoryListVos,page.getTotal()));  
}
```
## 新增分类
### 接口分析
点击标签管理的新增按钮可以实现新增标签的功能

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/content/category|需要 token 请求头|
- 请求体格式:
```json
{"name":"分类名","description":"描述","status":"状态"}
```
- 响应格式： 
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
- AddCategoryDto
```java
package com.xinzhou.domain.dto;  
  
import io.swagger.annotations.ApiModel;  
import lombok.Data;  
  
@Data  
@ApiModel(description = "添加分类dto")  
public class AddCategoryDto {  
  
    private String name;  
    private String description;  
    private String status;  
}
```
- CategoryController
```java
@PostMapping()  
@SystemLog(businessName = "新增分类")  
public ResponseResult addCategory(@RequestBody AddCategoryDto addCategoryDto){  
    Category category = BeanCopyUtils.copyBean(addCategoryDto, Category.class);  
    categoryService.save(category);  
    return ResponseResult.okResult();  
}
```

## 删除分类
### 接口分析
例如 content/category/6 代表删除 id 为6的标签数据。删除后在列表中是否查看不到该条数据，但是数据库中该条数据还是存在的，只是修改了逻辑删除字段的值

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|DELETE|content/category/{id}|需要 token 请求头|
- 响应
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
- CategoryController
```java
@DeleteMapping("/{id}")  
@SystemLog(businessName = "删除分类")  
public ResponseResult delete(@PathVariable(value = "id") Long id){  
    categoryService.removeById(id);  
    return ResponseResult.okResult();  
}
```
## 修改分类
### 接口分析
- ①根据分类 id 来获取某一条分类的信息，当用户点击修改按钮时触发，展示在弹框里面。例如：content/category/6 代表获取 id 为6的标签数据

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|content/category/{id}|需要 token 请求头|
- 响应格式：
```json
{
	"code":200,
	"data":{
        "id":1,
		"name":"分类名",
		"status":"0",
        "description":"分类描述",
        "delFlag":"0",
        "pid":"-1",
	},
	"msg":"操作成功"
}
```
- ②修改分类接口:

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|PUT|content/category|需要 token 请求头|
- 请求体格式： 
```json
{"name":"分类名","description":"描述","status":"状态"}
```
- 响应格式： 
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
- CategoryController
```java
@GetMapping("/{id}")  
@SystemLog(businessName = "分类详情")  
public ResponseResult getInfo(@PathVariable(value = "id") Long id){  
    Category category = categoryService.getById(id);  
    return ResponseResult.okResult(category);  
}  
  
@PutMapping()  
@SystemLog(businessName = "修改分类")  
public ResponseResult edit(@RequestBody Category category){  
    categoryService.updateById(category);  
    return ResponseResult.okResult();  
}
```
# 文章列表
## 查询文章
### 接口设计
在 '内容管理 -> 文章管理' 页面查询出有效的已发布文章的信息

|   |   |   |
|---|---|---|
|请求方式|请求路径|是否需求token头|
|Get|/content/article/list|是|
- 请求参数:
```txt
pageNum: 页码

pageSize: 每页条数

title：文章标题

summary：文章摘要
```
- 响应格式:
```json
{
	"code":200,
	"data":{
		"rows":[
			{
				"categoryId":"1",
				"content":"文章内容",
				"createTime":"2023-08-10 07:20:11",
				"id":"1",
				"isComment":"0",
				"isTop":"1",
				"status":"0",
				"summary":"文章摘要",
				"thumbnail":"文章缩略图.png|jpg",
				"title":"文章标题",
				"viewCount":"文章被浏览的次数"
			}
		],
		"total":"1"
	},
	"msg":"操作成功"
}
```
### 代码实现
- ArticleServiceImpl
```java
/**  
 * 分页查询文章  
 * @param pageNum  
 * @param pageSize  
 * @param title  
 * @param summary  
 * @return  
 */  
@Override  
public ResponseResult<ArticleListVo> list(Integer pageNum, Integer pageSize, String title, String summary) {  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.like(StringUtils.hasText(title),Article::getTitle,title);  
    queryWrapper.like(StringUtils.hasText(summary),Article::getSummary,summary);  
  
    Page<Article> page = new Page<>();  
    page = page(page, queryWrapper);  
  
    //从redis中查询浏览量  
    List<Article> articles = page.getRecords();  
    List<Article> articleList = articles.stream()  
            .map(article -> {  
                Integer viewCount = redisCache.getCacheMapValue("article:viewCount", article.getId().toString());  
                //如果后台刚添加的文章，前台又没启动时，会查询不到redis中的浏览量，则不进行设置  
                if (Objects.nonNull(viewCount)){  
                    article.setViewCount(viewCount.longValue());  
                }  
                return article;  
            })  
            .collect(Collectors.toList());  
    List<ArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(articleList, ArticleListVo.class);  
    return ResponseResult.okResult(new PageVo(articleListVos,page.getTotal()));  
}
```

## 修改文章
### 接口设计
- ①先查询根据文章 id 查询对应的文章

|   |   |   |
|---|---|---|
|请求方式|请求路径|是否需求token头|
|Get|content/article/{id}|是|
- 请求参数:id: 文章 id
- 响应
```json
{
	"code":200,
	"data":{
		"categoryId":"1",
		"content":"文章内容",
		"createBy":"1",
		"createTime":"2023-08-28 15:15:46",
		"delFlag":0,
		"id":"10",
		"isComment":"0",
		"isTop":"1",
		"status":"0",
		"summary":"文章摘要",
		"tags":[
			"1",
			"4",
			"5"
		],
		"thumbnail":"文章缩略图.png|jpg",
		"title":"文章标题",
		"updateBy":"1",
		"updateTime":"2022-08-28 15:15:46",
		"viewCount":"0"
	},
	"msg":"操作成功"
}
```
- ②然后才是修改文章

|   |   |   |
|---|---|---|
|请求方式|请求路径|是否需求token头|
|PUT|content/article|是|

- 请求体参数格式:
```json
{
    "categoryId":"1",
    "content":"文章内容",
    "createBy":"1",
    "createTime":"2023-08-28 15:15:46",
    "delFlag":0,
    "id":"10",
    "isComment":"0",
    "isTop":"1",
    "status":"0",
    "summary":"文章摘要",
    "tags":[
        "1",
        "4",
        "5"
    ],
    "thumbnail":"文章缩略图.png|jpg",
    "title":"文章标题",
    "updateBy":"1",
    "updateTime":"2022-08-28 15:15:46",
    "viewCount":"0"
}
```
- 响应格式:
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
- ArticleServiceImpl
```java
/**  
 * 后台查询文章详细  
 * @param id  
 * @return  
 */  
@Override  
public ResponseResult<ArticleVo> getInfo(Long id) {  
    //根据id查询文章  
    Article article = getById(id);  
  
    //-------------------从redis查询文章的浏览量，展示在文章详情---------------------------  
    Integer viewCount = redisCache.getCacheMapValue("article:viewCount", id.toString());  
    //如果后台刚添加的文章，前台又没启动时，会查询不到redis中的浏览量，则不进行设置  
    if (Objects.nonNull(viewCount)){  
        article.setViewCount(viewCount.longValue());  
    }  
  
    //封装  
    ArticleVo articleVo = BeanCopyUtils.copyBean(article, ArticleVo.class);  
  
    //根据文章id查询文章标签  
    LambdaQueryWrapper<ArticleTag> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(ArticleTag::getArticleId,id);  
    List<ArticleTag> articleTags = articleTagService.list(queryWrapper);  
    List<Long> tags = articleTags.stream().map(ArticleTag::getTagId).collect(Collectors.toList());  
  
  
    //使用Optional的ofNullable来防止空指针，并将categoryName设置到article中  
    Optional<ArticleVo> categoryOptional = Optional.ofNullable(articleVo);  
    categoryOptional.ifPresent(articleVo1 -> articleVo1.setTags(tags));  
  
  
    //封装响应返回  
    return ResponseResult.okResult(articleVo);  
}  
  
/**  
 * 修改文章  
 * @param editArticleDto  
 * @return  
 */  
@Override  
@Transactional//开启事务  
public ResponseResult edit(EditArticleDto editArticleDto) {  
  
    Article article = BeanCopyUtils.copyBean(editArticleDto, Article.class);  
    LambdaUpdateWrapper<Article> updateWrapper = new LambdaUpdateWrapper<>();  
    updateWrapper.eq(Article::getId,editArticleDto.getId());  
    update(article,updateWrapper);  
  
  
  
// 删除旧的文章标签关联  
LambdaQueryWrapper<ArticleTag> deleteWrapper = new LambdaQueryWrapper<>();  
deleteWrapper.eq(ArticleTag::getArticleId, editArticleDto.getId());  
articleTagService.remove(deleteWrapper); 
  
    // 获取新的文章标签关联列表并添加  
    List<ArticleTag> articleTags = editArticleDto.getTags().stream()  
            .map(tagId -> new ArticleTag(editArticleDto.getId(), tagId))  
            .collect(Collectors.toList());  
    articleTagService.saveBatch(articleTags);  
  
    return ResponseResult.okResult();  
}
```
- 这里要注意删除原有文章关联
## 删除文章
### 接口设计

点击文章后面的删除按钮可以删除该文章。注意: 是逻辑删除不是物理删除

|   |   |   |
|---|---|---|
|请求方式|请求路径|是否需求token头|
|DELETE|content/article/{id}|是|
- 请求 id：要删除的文章 id
- 响应
```json
{
	"code":200,
	"msg":"操作成功"
}
```
### 代码实现
```java
@DeleteMapping("/{id}")  
@SystemLog(businessName = "删除文章")  
public ResponseResult remove(@PathVariable Long id){  
    articleService.removeById(id);  
    return ResponseResult.okResult();  
}
```