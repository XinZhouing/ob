# 文章列表
## 表分析
![[Pasted image 20231221205536.png]]
## 热门文章接口分析
需要查询浏览量最高的前10篇文章的信息。要求展示文章标题和浏览量。把能让用户自己点击跳转到具体的文章详情进行浏览
注意：不能把草稿展示出来，不能把删除了的文章查询出来。要按照浏览量进行降序排序
## 统一响应格式
在公共模块下新建枚举类和响应实体类
```java
package com.xinzhou.enums;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:52  
 */public enum AppHttpCodeEnum {  
    // 成功  
    SUCCESS(200,"操作成功"),  
    // 登录  
    NEED_LOGIN(401,"需要登录后操作"),  
    NO_OPERATOR_AUTH(403,"无权限操作"),  
    SYSTEM_ERROR(500,"出现错误"),  
    USERNAME_EXIST(501,"用户名已存在"),  
    PHONENUMBER_EXIST(502,"手机号已存在"),  
    EMAIL_EXIST(503, "邮箱已存在"),  
    REQUIRE_USERNAME(504, "必需填写用户名"),  
    LOGIN_ERROR(505,"用户名或密码错误");  
    int code;  
    String msg;  
  
    AppHttpCodeEnum(int code, String errorMessage){  
        this.code = code;  
        this.msg = errorMessage;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
}
```
```java
package com.xinzhou.domain;  
  
import com.fasterxml.jackson.annotation.JsonInclude;  
import com.xinzhou.enums.AppHttpCodeEnum;  
  
import java.io.Serializable;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:49  
 *///统一响应格式。实体类，或者这个类严格来说叫响应体  
@JsonInclude(JsonInclude.Include.NON_NULL)  
public class ResponseResult<T> implements Serializable {  
    private Integer code;  
    private String msg;  
    private T data;  
  
    public ResponseResult() {  
        this.code = AppHttpCodeEnum.SUCCESS.getCode();  
        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();  
    }  
  
    public ResponseResult(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg, T data) {  
        this.code = code;  
        this.msg = msg;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
    }  
  
    public static ResponseResult errorResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.error(code, msg);  
    }  
    public static ResponseResult okResult() {  
        ResponseResult result = new ResponseResult();  
        return result;  
    }  
    public static ResponseResult okResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.ok(code, null, msg);  
    }  
  
    public static ResponseResult okResult(Object data) {  
        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());  
        if(data!=null) {  
            result.setData(data);  
        }  
        return result;  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums){  
        return setAppHttpCodeEnum(enums,enums.getMsg());  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){  
        return setAppHttpCodeEnum(enums,msg);  
    }  
  
    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){  
        return okResult(enums.getCode(),enums.getMsg());  
    }  
  
    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){  
        return okResult(enums.getCode(),msg);  
    }  
  
    public ResponseResult<?> error(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data, String msg) {  
        this.code = code;  
        this.data = data;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(T data) {  
        this.data = data;  
        return this;  
    }  
  
    public Integer getCode() {  
        return code;  
    }  
  
    public void setCode(Integer code) {  
        this.code = code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
  
    public T getData() {  
        return data;  
    }  
  
    public void setData(T data) {  
        this.data = data;  
    }  
  
}
```
## 代码实现
- 在 ArticleServiceImpl 中实现 hotArticleList 方法
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    return ResponseResult.okResult(articles);  
}
```
## 测试接口
访问： http://localhost:7777/article/hotArticleList 
![[Pasted image 20231221213915.png]]
## 后端解决跨域
```java
package com.xinzhou.config;  
  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.servlet.config.annotation.CorsRegistry;  
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  
  
@Configuration  
public class WebConfig implements WebMvcConfigurer {  
  
    @Override  
    public void addCorsMappings(CorsRegistry registry) {  
        // 设置允许跨域的路径  
        registry.addMapping("/**")  
                // 设置允许跨域请求的域名  
                .allowedOriginPatterns("*")  
                // 是否允许cookie  
                .allowCredentials(true)  
                // 设置允许的请求方式  
                .allowedMethods("GET", "POST", "DELETE", "PUT")  
                // 设置允许的header属性  
                .allowedHeaders("*")  
                // 跨域允许时间  
                .maxAge(3600);  
    }  
  
}
```
## 前端项目的启动
	npm install
	npm run dev
- 前后端联调
![[Pasted image 20231221220012.png]]
## 优化
- VO 优化
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    //bean拷贝  
    List<HotArticleVo> articleVos = new ArrayList<>();  
    for(Article article : articles){  
        HotArticleVo vo = new HotArticleVo();  
        BeanUtils.copyProperties(article,vo);  
        articleVos.add(vo);  
    }  
  
    return ResponseResult.okResult(articleVos);  
}
```
- 字面值处理
	实际项目中都不允许直接在代码中使用字面值 (代码中的固定值)。都需要定义成常量来使用。这种方式有利于提高代码的可维护性。
```java
package com.xinzhou.constants;  
  
public class SystemCanstants {  
  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
      
    /**  
     *  文章是正常分布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
      
}
```
优化后：
```java
//必须是正式文章  
queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);
```
- Bean 拷贝的封装
```java
package com.xinzhou.utils;  
  
import org.springframework.beans.BeanUtils;  
import java.util.List;  
import java.util.stream.Collectors;  
  
public class BeanCopyUtils {  
    private BeanCopyUtils(){  
    }  
  
    public static <V> V copyBean(Object source,Class<V> clazz) {  
        //创建目标对象  
        V result = null;  
        try {  
            result = clazz.newInstance();  
            //实现属性拷贝  
            BeanUtils.copyProperties(source, result);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        //返回结果  
        return result;  
    }  
  
    public static <O,V> List<V> copyBeanList(List<O> list,Class<V> clazz){  
        return list.stream()  
                .map(o -> copyBean(o, clazz))  
                .collect(Collectors.toList());  
    }  
}
```
优化后：
```java
//bean拷贝  
List<HotArticleVo> articleVos = BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);
```
- 测试
![[Pasted image 20231221222806.png]]
# 分类列表
## 表分析
![[Pasted image 20231221223044.png]]
## 需求分析
	页面上需要展示分类列表，用户可以点击具体的分类查看该分类下的文章列表。要求只展示有发布正式文章的分类 。要求必须是正常(非禁用)状态的分类
## 代码实现
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Article;  
import com.xinzhou.domain.pojo.Category;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.service.ArticleService;  
import com.xinzhou.service.CategoryService;  
import com.xinzhou.mapper.CategoryMapper;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Set;  
import java.util.function.Function;  
import java.util.function.Predicate;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【category(分类表)】的数据库操作Service实现  
* @createDate 2023-12-21 22:39:08  
*/  
@Service  
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService{  
  
    @Autowired  
    private ArticleService articleService;  
    @Override  
    public ResponseResult getCategoryList() {  
        //查询状态为已发布的文章表  
        LambdaQueryWrapper<Article> articleWrapper = new LambdaQueryWrapper<>();  
        articleWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
        List<Article> articleList = articleService.list(articleWrapper);  
        //获取文章的categoryId并去重  
        Set<Long> categoryIds = articleList.stream()  
                .map(Article::getCategoryId)  
                .collect(Collectors.toSet());  
        //查询分类状态为正常状态的分类表  
        List<Category> categories = listByIds(categoryIds);  
  
        categories = categories.stream()  
                .filter(category -> SystemCanstants.STATUS_NORMAL.equals(category.getStatus()))  
                .collect(Collectors.toList());  
        //封装vo  
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(categories, CategoryVo.class);  
        return ResponseResult.okResult(categoryVos);  
    }  
}
```
# 分页查询文章列表
## 接口分析
	首页需要查询所有的文章列表。分类页面需要查询对应分类下的文章列表。只能查询正式发布的文章，置顶的文章要显示在最前面
## 代码实现
	在公共模块的config 目录新建 MybatisPlusConfig 类，作用是配置 MyBatisPlus 的分页插件，不然分页没有效果
```java
package com.xinzhou.config;  
  
import com.baomidou.mybatisplus.annotation.DbType;  
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
@Configuration  
@MapperScan("com.xinzhou.mapper")  
public class MyBatisPlusConfig {  
  
    /**  
     * 配置分页插件  
     * @return  
     */  
    @Bean  
    public MybatisPlusInterceptor mybatisPlusInterceptor(){  
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();  
        //如果配置多个插件,切记分页最后添加  
        //如果有多数据源可以不配具体类型 否则都建议配上具体的DbType  
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));  
        return interceptor;  
    }  
}
```
	新建 PageVo 实体类，用于封装返回分页的数据
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.List;  
  
/**  
 * 封装返回分页的数据  
 */  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class PageVo {  
  
    private List rows;  
  
    private Long total;  
}
```
	解决问题：categoryName字段没有返回值，使用stream流，从article表中获取categoryId用于查询categoryName设置到Article对象中（在Article实体类中加入categoryName字段，并使用@TableFiled注释标识为数据库中不存在）
```java
@Override  
public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {  
    //条件：有categoryId查询时要传入相同的，状态是正式发布的，对isTop进行降序排序  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Objects.nonNull(categoryId)&&categoryId>0,Article::getCategoryId,categoryId);  
    queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
    queryWrapper.orderByDesc(Article::getIsTop);  
  
    //分页查询  
    Page<Article> page = new Page<>(pageNum,pageSize);  
    page(page,queryWrapper);  
  
    //解决：查询categoryName为null问题，通过articleId去查询articleName进行设置  
    List<Article> articles = page.getRecords();  
    articles.stream()  
            .map(article -> {  
                //简化为一行：可以使用Lombok中@Accessors（chain=ture）注释Article实体类，可以将类中set方法的返回值设置为该类  
                article.setCategoryName(categoryService.getById(article.getCategoryId()).getName());  
                return article;  
            })  
            .collect(Collectors.toList());  
  
    //封装vo  
    List<ArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(page.getRecords(), ArticleListVo.class);  
  
    PageVo pageVo = new PageVo(articleListVos, page.getTotal());  
  
    return ResponseResult.okResult(pageVo);  
}
```
## FastJson 配置
	由于ArticleListVO类的createTime成员变量是Date类型，默认是由java的Jackson来处理，使用 ISO-8601 规范来处理日期时间格式。ISO-8601 是一种国际标准的日期时间表示法，例如："2023-07-21T06:53:24"。我们不希望时间被处理成这种格式。解决: 在WebConfig中配置使用FastJson 
```java
/**  
 * FastJson配置：时间格式问题  
 */  
@Bean//使用@Bean注入fastJsonHttpMessageConvert  
public HttpMessageConverter fastJsonHttpMessageConverters() {  
    //1.需要定义一个Convert转换消息的对象  
    FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();  
    FastJsonConfig fastJsonConfig = new FastJsonConfig();  
    fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);  
    fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");  
  
    SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);  
  
    fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);  
    fastConverter.setFastJsonConfig(fastJsonConfig);  
    HttpMessageConverter<?> converter = fastConverter;  
    return converter;  
}  
  
@Override  
//配置消息转换器  
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {  
    //增加我们的消息转换器  
    converters.add(fastJsonHttpMessageConverters());  
}
```
# 文章详情接口
## 接口分析
	要求在文章列表点击阅读全文时能够跳转到文章详情页面，可以让用户阅读文章正文。并且要在文章详情中展示其分类名。响应格式：
```json
{
  "code": 200,
  "data": {
    "categoryId": "1",
    "categoryName": "java",
    "content": "文章详情的具体文章内容",
    "createTime": "2022-01-23 23:20:11",
    "id": "1",
    "isComment": "0",
    "title": "SpringSecurity从入门到精通",
    "viewCount": "114"
  },
  "msg": "操作成功"
}
```
## 常用的 HTTP 请求形式
	以 GET /article/{id} 为例的路径参数形式，下面两种是比较常用的。不常用的有'请求体形式'、'请求头形式'

|   |   |   |
|---|---|---|
|请求形式|示例|描述|
|路径参数形式|/articles/{id}|参数作为路径的一部分，表示明确的资源标识符或必需的参数。|
|查询参数形式|/articles?id=1&num=1|参数通过 "?" 或 "&" 的方式附加在 URL 的末尾，适合传递可选参数或过滤条件。|
## 代码实现
```java
@Override  
public ResponseResult getArticleDetail(Long id) {  
    //根据id查询文章  
    Article article = getById(id);  
  
    //根据分类id查询分类名  
    Category category = categoryService.getById(article.getCategoryId());  
  
    //使用Optional的ofNullable来防止空指针，并将categoryName设置到article中  
    Optional<Category> categoryOptional = Optional.ofNullable(category);  
    categoryOptional.ifPresent(category1 -> article.setCategoryName(category1.getName()));  
  
    //转换为vo  
    ArticleDetailVo articleDetailVo = BeanCopyUtils.copyBean(article, ArticleDetailVo.class);  
  
    //封装响应返回  
    return ResponseResult.okResult(articleDetailVo);  
}
```
# 友链功能
## 表分析
![[Pasted image 20231222231535.png]]
## 接口分析
	在友链页面要查询出所有的审核通过的友链，响应格式如下
```json
{
  "code": 200,
  "data": [
    {
      "address": "https://www.baidu.com",
      "description": "sda",
      "id": "1",
      "logo": "图片url1",
      "name": "sda"
    },
    {
      "address": "https://www.qq.com",
      "description": "dada",
      "id": "2",
      "logo": "图片url2",
      "name": "sda"
    }
  ],
  "msg": "操作成功"
}
```
## 代码实现
```java
@Override  
public ResponseResult getAllLink() {  
    //查询所有审核通过的友链  
    LambdaQueryWrapper<Link> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Link::getStatus, SystemCanstants.LINK_STATUS_NORMAL);  
    List<Link> links = list(queryWrapper);  
    //转换vo  
    List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(links, LinkVo.class);  
    return ResponseResult.okResult(linkVos);  
}
```
# 登录功能
## 表分析
![[Pasted image 20231223213733.png]]
需要实现登录功能，有些功能必须登录后才能使用，未登录状态是不能使用的。请求形式如下
- 请求体
```json
{
    "userName":"sg",
    "password":"1234"
}
```
- 响应格式
```json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk",
        "userInfo": {
            "avatar": "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F3bf9c263bc0f2ac5c3a7feb9e218d07475573ec8.gi",
            "email": "23412332@qq.com",
            "id": 1,
            "nickName": "sg333",
            "sex": "1"
        }
    },
    "msg": "操作成功"
}
```
## 思路分析
- 登录
	1. 自定义登录接口
		调用 ProviderManager 的方法进行认证，认证通过生成 jwt
		把用户信息存入redis
	2. 自定义 UserDetailService 
		在这个实现类中查询数据库
注意配置 passwordEncoder 为 BCryptPasswordEncorder
		
- 校验
	1. 定义 Jwt 认证过滤器
		获取 token
		解析 token 获取 userID 
		从 redis 中获取用户信息
		存入 SecurityContextHolder 
		
具体实现流程可查看 [[SpringSecurity study]] 
## 准备工作
- 相关依赖
```xml
<!--SpringSecurity启动器-->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>  
<!--redis依赖-->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis</artifactId>  
</dependency>  
<!--fastjson依赖-->  
<dependency>  
    <groupId>com.alibaba</groupId>  
    <artifactId>fastjson</artifactId>  
</dependency>  
<!--jwt依赖-->  
<dependency>  
    <groupId>io.jsonwebtoken</groupId>  
    <artifactId>jjwt</artifactId>  
</dependency>
```
- 配置类和工具类
[[FastJsonRedisSerializer]]
[[RedisConfig]]
[[JwtUtils]]
[[RedisCache]]
[[WebUtils]]
## 登录代码实现
### BlogUserController
```java
package com.xinzhou.controller;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.service.BlogLoginService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
public class BlogLoginController {  
    @Autowired  
    private BlogLoginService blogLoginService;  
  
    @PostMapping("/login")  
    public ResponseResult login(@RequestBody User user){  
        return blogLoginService.login(user);  
    }  
}
```
### BlogLoginService 
```java
package com.xinzhou.service;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
  
public interface BlogLoginService {  
    ResponseResult login(User user);  
}
```
### SecurityConfig
```java
package com.xinzhou.config;  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
				//除上面外的所有请求全部不需要认证即可访问  
				.anyRequest().permitAll(); 
        //配置认证过滤器  
//        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
//        //配置异常处理器  
//        http.exceptionHandling()  
//                //配置认证失败处理器  
//                .authenticationEntryPoint(authenticationEntryPoint)  
//                //配置授权失败处理器  
//                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
### BlogLoginServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.BlogUserLoginVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.BlogLoginService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.Authentication;  
import org.springframework.stereotype.Service;  
  
import java.util.Objects;  
  
/**  
 * 认证，判断用户登录是否成功  
 */  
@Service  
public class BlogLoginServiceImpl implements BlogLoginService {  
    @Autowired  
    private AuthenticationManager authenticationManager;  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    public ResponseResult login(User user) {  
        //封装登录的用户名和密码  
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());  
        //在下一行之前，封装的数据会先走UserDetailsServiceImpl实现类  
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);  
        //上面那一行会得到所有的认证用户信息authenticate。然后下一行需要判断用户认证是否通过，如果authenticate的值是null，就说明认证没有通过  
  
        //判断是否验证通过  
        if(Objects.isNull(authenticate))  
            throw new RuntimeException("用户名或密码错误");  
  
        //获取userId生成Token  
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();  
        String userId = loginUser.getUser().getId().toString();  
        String jwt = JwtUtil.createJWT(userId);  
        //把用户信息存入redis  
        redisCache.setCacheObject("bloglogin:"+userId,loginUser);  
        //把token和userInfo封装并返回  
        //把User转换成UserInfoVo  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);  
        BlogUserLoginVo vo = new BlogUserLoginVo(jwt,userInfoVo);  
        return ResponseResult.okResult(vo);  
    }  
}
```
### UserDetailServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.mapper.UserMapper;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.core.userdetails.UsernameNotFoundException;  
import org.springframework.stereotype.Service;  
  
import java.util.Objects;  
  
/**  
 * 当BlogLoginServiceImpl类封装好登录的用户名和密码之后，就会传到当前这个实现类  
 */  
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private UserMapper userMapper;  
    @Override  
    //在这里之前，我们已经拿到了登录的用户名和密码。UserDetails是SpringSecurity官方提供的接口  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
  
        //根据用户名查询用户信息  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getUserName,username);  
        User user = userMapper.selectOne(queryWrapper);  
        //判断是否查询到用户 如果没查询到则抛出异常  
        if (Objects.isNull(user))  
            throw new RuntimeException("用户不存在");//后期会对异常进行统一处理  
        //TODO 查询权限信息封装  
        //返回用户信息  
        return new LoginUser(user);  
    }  
}
```
### LoginUser 
```java
package com.xinzhou.domain.pojo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
import org.springframework.security.core.GrantedAuthority;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Collection;  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
//UserDetails是SpringSecurity官方提供的接口  
public class LoginUser implements UserDetails {  
    private User user;  
  
    /**  
     * 用于返回权限信息。现在我们正在实现'认证'，'权限'后面才用得到。所以返回null即可  
     * 当要查询用户信息的时候，我们不能单纯返回null，要重写这个方法，作用是返回权限信息  
     * @return  
     */  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return null;  
    }  
  
    /**  
     * 用于获取用户密码。由于使用的实体类是User，所以获取的是数据库的用户密码  
     * @return  
     */  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    /**  
     * 用于获取用户名。由于使用的实体类是User，所以获取的是数据库的用户名  
     * @return  
     */  
    @Override  
    public String getUsername() {  
        return user.getUserName();  
    }  
  
    /**  
     * 判断登录状态是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isAccountNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断账号是否被锁定。把这个改成true，表示未锁定  
     * @return  
     */  
    @Override  
    public boolean isAccountNonLocked() {  
        return true;  
    }  
  
    /**  
     * 判断登录凭证是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断用户是否可用。把这个改成true，表示可用状态  
     * @return  
     */  
    @Override  
    public boolean isEnabled() {  
        return true;  
    }  
}
```
### BlogUserLoginVo 
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class BlogUserLoginVo {  
    private String token;  
    private UserInfoVo userInfo;  
}
```
### UserInfoVo 
```java
package com.xinzhou.domain.vo;  
  
import com.baomidou.mybatisplus.annotation.IdType;  
import com.baomidou.mybatisplus.annotation.TableId;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class UserInfoVo {  
    /**  
     * 主键  
     */  
    @TableId(type = IdType.AUTO)  
    private Long id;  
  
    /**  
     * 用户名  
     */  
    private String userName;  
  
    /**  
     * 昵称  
     */  
    private String nickName;  
  
    /**  
     * 邮箱  
     */  
    private String email;  
  
    /**  
     * 用户性别（0男，1女，2未知）  
     */  
    private String sex;  
  
    /**  
     * 头像  
     */  
    private String avatar;  
  
}
```
### 遇到的问题
`java.lang.ClassNotFoundException:javax.xml.bind.DatatypeConverter`

解决方案：
```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
```
因为 javax.xml.bind 在 jdk8中有，但是在更高版本就没有了，所以我们加上就行了。
# 认证过滤器代码实现
校验思路

1. 定义 Jwt 认证过滤器  
    获取 token  
    解析 token 获取 userID  
    从 redis 中获取用户信息  
    存入 SecurityContextHolder 
### JwtAuthenticationTokenFilter 
```java
package com.xinzhou.filter;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import com.xinzhou.utils.WebUtils;  
import io.jsonwebtoken.Claims;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Component;  
import org.springframework.util.StringUtils;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.util.Objects;  
  
@Component  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
  
        //获取 token        
        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)){  
            //该接口不需要token，直接放行  
            filterChain.doFilter(request,response);  
            return;  
        }  
        //解析 token 获取 userID        Claims claims = null;  
        try {  
            claims = JwtUtil.parseJWT(token);  
        } catch (Exception e) {  
            e.printStackTrace();  
            //token超时或token非法  
            //响应给前端需要重新登录，通过WebUtils工具类设置响应码  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        String userId = claims.getSubject();  
        //从 redis 中获取用户信息  
        LoginUser loginUser = redisCache.getCacheObject("bloglogin:" + userId);  
        //如果获取不到用户信息  
        if(Objects.isNull(loginUser)){  
            //说明登录过期，重新登录  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        //存入 SecurityContextHolder        
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
  
        filterChain.doFilter(request,response);  
    }  
}
```
### 配置认证过滤器 
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
//        //配置异常处理器  
//        http.exceptionHandling()  
//                //配置认证失败处理器  
//                .authenticationEntryPoint(authenticationEntryPoint)  
//                //配置授权失败处理器  
//                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 认证授权的异常处理
	目前我们的项目在认证出错或者权限不足的时候响应回来的 Json，默认是使用 Security 官方提供的响应的格式，但是这种响应的格式肯定是不符合我们项目的接口规范的。所以需要自定义异常处理
	
	我们需要去实现AuthenticationEntryPoint(官方提供的认证失败处理器)类、AccessDeniedHandler(官方提供的授权失败处理器)类，然后配置给Security
### 认证失败处理器实现类 AuthenticationEntryPointImpl
```java
package com.xinzhou.handler.security;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.security.authentication.BadCredentialsException;  
import org.springframework.security.authentication.InsufficientAuthenticationException;  
import org.springframework.security.core.AuthenticationException;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.stereotype.Component;  
  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
  
@Component  
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {  
    @Override  
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {  
        //打印异常信息  
        e.printStackTrace();  
  
        //判断是登录才出现异常(返回'用户名或密码错误')，还是没有登录就访问特定接口才出现的异常(返回'需要登录后访问')，还是其它情况(返回'出现错误')  
        ResponseResult result = null;  
        if(e instanceof BadCredentialsException){  
            //第一个参数返回的是响应码，AppHttpCodeEnum是我们写的实体类。第二个参数是返回具体的信息  
            result = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR.getCode(),e.getMessage());  
        } else if(e instanceof InsufficientAuthenticationException){  
            result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
        } else {  
            result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),"认证或授权失败");  
        }  
  
        //将响应结果转化为Json响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```
### 授权失败处理器实现类 AccessDeniedHandlerImpl
```java
package com.xinzhou.handler.security;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.security.access.AccessDeniedException;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.stereotype.Component;  
  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
@Component  
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {  
    @Override  
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {  
        //打印异常信息  
        e.printStackTrace();  
  
        ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH);  
        //将响应结果转化为Json响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```
### 配置认证授权异常处理器
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 统一异常处理
实际我们在开发过程中可能需要做很多的判断校验，如果出现了非法情况我们是期望响应对应的提示的。但是如果我们每次都自己手动去处理就会非常麻烦。我们可以选择直接抛出异常的方式，然后对异常进行统一处理。把异常中的信息封装成 ResponseResult 响应给前端
- 在 framework 模块下新建 exception. SystemException 类
```java
package com.xinzhou.exception;  
  
import com.xinzhou.enums.AppHttpCodeEnum;  
  
/**  
 * @author xinxinzhou  
 * @date 2023/7/23 0023 21:54  
 *///统一异常处理  
public class SystemException extends RuntimeException{  
  
    private int code;  
  
    private String msg;  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    //定义一个构造方法，接收的参数是枚举类型，AppHttpCodeEnum是我们在framework工程定义的枚举类  
    public SystemException(AppHttpCodeEnum httpCodeEnum) {  
        super(httpCodeEnum.getMsg());  
        //把某个枚举类里面的code和msg赋值给异常对象  
        this.code = httpCodeEnum.getCode();  
        this.msg = httpCodeEnum.getMsg();  
    }  
}
```
- 在 framework 工模块下新建 handler. exception. GlobalExceptionHandler 类
```java
package com.xinzhou.handler.exception;  
  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import lombok.extern.slf4j.Slf4j;  
  
import org.springframework.web.bind.annotation.ExceptionHandler;  
import org.springframework.web.bind.annotation.RestControllerAdvice;  
  
/**  
 * @author 14674  
 * @date 2023/7/23 0023 22:03  
 *///@ControllerAdvice //对controller层的增强  
//@ResponseBody  
  
//或者用下面一个注解代替上面的两个注解  
@RestControllerAdvice  
  
//使用Lombok提供的Slf4j注解，实现日志功能  
@Slf4j  
  
//全局异常处理。最终都会在这个类进行处理异常  
public class GlobalExceptionHandler {  
  
    //SystemException是我们写的类。用户登录的异常交给这里处理  
    @ExceptionHandler(SystemException.class)  
    public ResponseResult systemExceptionHandler(SystemException e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult是我们写的类  
        return ResponseResult.errorResult(e.getCode(),e.getMsg());  
    }  
  
    //其它异常交给这里处理  
    @ExceptionHandler(Exception.class)  
    public ResponseResult exceptionHandler(Exception e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult、AppHttpCodeEnum是我们写的类  
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());//枚举值是500  
    }  
}
```
- 修改 BlogLoginController
```java
@RestController  
public class BlogLoginController {  
    @Autowired  
    private BlogLoginService blogLoginService;  
  
    @PostMapping("/login")  
    public ResponseResult login(@RequestBody User user){  
        //如果用户在进行登录时，没有传入'用户名',提示'必须要传用户名'。AppHttpCodeEnum是我们写的枚举类。SystemException是我们写的统一异常处理的类  
        if(!StringUtils.hasText(user.getUserName()))  
            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);  
        return blogLoginService.login(user);  
    }  
}
```
# 退出登录
## 接口分析
|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/logout|需要 token 请求头|
## 代码实现
- 在 BlogLoginServiceImpl 中实现退出登录
```java
/**  
 * 退出登录  
 * @return  
 */  
@Override  
public ResponseResult logout() {  
    //获取token，解析获取userId  
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
    LoginUser loginUser = (LoginUser) authentication.getPrincipal();  
    Long userId = loginUser.getUser().getId();  
    //删除redis中用户信息  
    redisCache.deleteObject("bloglogin:" + userId);  
    return ResponseResult.okResult();  
}
```
- 在 SecurityConfig 类修改为如下，增加了需要有登录状态才能执行退出登录，否则就报'401 需要登录后操作'
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //退出登录接口，需要登录才能调用  
                .antMatchers("/logout").authenticated()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 评论列表
## 评论表分析
![[Pasted image 20231224172656.png]]
## 接口分析
|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/comment/commentList|不需要 token 请求头(未登录也能看到评论信息)|
- Query 格式请求参数如下:
```
articleId:文章id
pageNum:页码
pageSize:每页条数
```
- 响应格式如下，包含了根评论+子评论:
```json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "评论内容(子评论)",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:06:21",
                        "id": "20",
                        "rootId": "1",
                        "toCommentId": "1",
                        "toCommentUserId": "1",
                        "toCommentUserName": "这条评论(子评论)回复的是哪个人",
                        "username": "发这条评论(子评论)的人"
                    }
                ],
                "content": "评论内容(根评论)",
                "createBy": "1",
                "createTime": "2022-01-29 07:59:22",
                "id": "1",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "发这条评论(根评论)的人"
            }
        ],
        "total": "15"
    },
    "msg": "操作成功"
}
```
## 代码实现-不考虑子评论
### 新建 CommentVo 类, 用来封装返回的评论
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class CommentVo {  
    private Long id;  
  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    //所回复评论的用户名  
    private String toCommentUserName;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */    private Long createBy;  
  
    /**  
     *     */    private Date createTime;  
  
    //评论人  
    private String username;  
  
}
```
### CommentServiceImpl 实现类
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.CommentVo;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.service.CommentService;  
import com.xinzhou.mapper.CommentMapper;  
import com.xinzhou.service.UserService;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.function.Function;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【comment(评论表)】的数据库操作Service实现  
* @createDate 2023-12-25 00:18:11  
*/  
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
    @Autowired  
    private UserService userService;  
  
    @Override  
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
  
        //查询对应文章的根评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        //对articleId进行判断  
        queryWrapper.eq(Comment::getArticleId,articleId);  
        //根评论的rootId为-1,SystemCanstants是我们写的解决字面值的类,COMMENT_ROOT标识评论为根评论  
        queryWrapper.eq(Comment::getRootId, SystemCanstants.COMMENT_ROOT);  
        //分页查询  
        Page<Comment> page = new Page<>(pageNum,pageSize);  
        page(page,queryWrapper);  
  
        //封装成CommentVo,  
        List<CommentVo> commentVos = toCommentVoList(page.getRecords());  
  
  
        //封装成响应实体并返回  
        return ResponseResult.okResult(new PageVo(commentVos,page.getTotal()));  
    }  
  
    /**  
     * 将封装CommentVo定义为方法调用  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
        //遍历vo集合  
        commentVos.stream()  
                .map(commentVo -> {  
                    //通过creatBy查询评论人的用户名  
                    String nickName = userService.getById(commentVo.getCreateBy()).getNickName();  
                    commentVo.setUsername(nickName);  
  
                    //通过toCommentUserId查询所评论的用户名昵称并赋值  
                    //如果toCommentUserId不为-1才进行查询，不为-1标识该评论不为根评论，有所回复的用户名  
                    if(!Objects.equals(commentVo.getToCommentUserId(), SystemCanstants.COMMENT_ROOT)){  
                        String toCommentUserName = userService.getById(commentVo.getToCommentUserId()).getNickName();  
                        commentVo.setToCommentUserName(toCommentUserName);  
                    }  
                    return commentVo;  
                }).collect(Collectors.toList());  
        return commentVos;  
    }  
}
```
## 代码实现-考虑子评论 
### 在 CommentVo 类中增加了子评论字段
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
import java.util.List;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class CommentVo {  
    private Long id;  
  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    //所回复评论的用户名  
    private String toCommentUserName;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */    private Long createBy;  
  
    /**  
     *     */    private Date createTime;  
  
    //评论人  
    private String username;  
  
    //子评论  
    private List<CommentVo> children;  
  
}
```
### 把 CommentServiceImpl 修改为如下，增加了查询子评论、子评论按照时间排序、根评论按照时间排序
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.CommentVo;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.service.CommentService;  
import com.xinzhou.mapper.CommentMapper;  
import com.xinzhou.service.UserService;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.function.Function;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【comment(评论表)】的数据库操作Service实现  
* @createDate 2023-12-25 00:18:11  
*/  
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
    @Autowired  
    private UserService userService;  
  
    @Override  
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
  
        //查询对应文章的根评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        //对articleId进行判断  
        queryWrapper.eq(Comment::getArticleId,articleId);  
        //根评论的rootId为-1,SystemCanstants是我们写的解决字面值的类,COMMENT_ROOT标识评论为根评论  
        queryWrapper.eq(Comment::getRootId, SystemCanstants.COMMENT_ROOT);  
        //分页查询  
        Page<Comment> page = new Page<>(pageNum,pageSize);  
        page(page,queryWrapper);  
  
        //封装成CommentVo,  
        List<CommentVo> commentVos = toCommentVoList(page.getRecords());  
  
        //查询所有根评论对应的子评论集合，并赋值给对应的属性。  
        commentVos.stream()  
                .map( commentVo -> {  
                    //查询对应的子评论  
                    List<CommentVo> children = getChildren(commentVo.getId());  
                    //赋值  
                    commentVo.setChildren(children);  
                    return commentVo;  
                }).collect(Collectors.toList());  
  
  
        //封装成响应实体并返回  
        return ResponseResult.okResult(new PageVo(commentVos,page.getTotal()));  
    }  
  
    /**  
     * 根据根评论的id查询对应子评论的集合  
     * @param id 根评论的id  
     * @return  
     */  
    private List<CommentVo> getChildren(Long id){  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(Comment::getRootId,id)  
                //对子评论按照时间进行排序  
                .orderByAsc(Comment::getCreateTime);  
        List<Comment> comments = list(queryWrapper);  
        //调用toCommentVoList,封装CommentVo  
        return toCommentVoList(comments);  
    }  
  
    /**  
     * 将封装CommentVo定义为方法调用  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
        //遍历vo集合  
        commentVos.stream()  
                .map(commentVo -> {  
                    //通过creatBy查询评论人的用户名  
                    String nickName = userService.getById(commentVo.getCreateBy()).getNickName();  
                    commentVo.setUsername(nickName);  
  
                    //通过toCommentUserId查询所评论的用户名昵称并赋值  
                    //如果toCommentUserId不为-1才进行查询，不为-1标识该评论不为根评论，有所回复的用户名  
                    if(!Objects.equals(commentVo.getToCommentUserId(), SystemCanstants.COMMENT_ROOT)){  
                        String toCommentUserName = userService.getById(commentVo.getToCommentUserId()).getNickName();  
                        commentVo.setToCommentUserName(toCommentUserName);  
                    }  
                    return commentVo;  
                }).collect(Collectors.toList());  
        return commentVos;  
    }  
}
```
# 发送评论
## 接口分析
用户登录后可以对文章发表评论，也可以对已有的评论进行回复

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/comment|需要 token 头|
【请求体】
回复了文章。0表示文章评论，如果是友链评论，type 应该为1：
```json
{"articleId":1,"type":0,"rootId":-1,"toCommentId":-1,"toCommentUserId":-1,"content":"评论了文章"}
```
【响应格式】
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
### SecurityUtils 类
```java
package com.xinzhou.utils;  
  
import com.xinzhou.domain.pojo.LoginUser;  
import org.springframework.security.core.Authentication;  
import org.springframework.security.core.context.SecurityContextHolder;  
  
/**  
 * @author 35238  
 * @date 2023/7/26 0026 20:43  
 */  
//在'发送评论'功能那里会用到的工具类  
public class SecurityUtils {  
  
    /**  
     * 获取用户的userid  
     **/    public static LoginUser getLoginUser() {  
        return (LoginUser) getAuthentication().getPrincipal();  
    }  
  
    /**  
     * 获取Authentication  
     */    public static Authentication getAuthentication() {  
        return SecurityContextHolder.getContext().getAuthentication();  
    }  
  
    /**  
     * 指定userid为1的用户就是网站管理员  
     * @return  
     */  
    public static Boolean isAdmin(){  
        Long id = getLoginUser().getUser().getId();  
        return id != null && 1L == id;  
    }  
  
    public static Long getUserId() {  
        return getLoginUser().getUser().getId();  
    }  
}
```
### 配置 MP 自动填充公共字段
```java
package com.xinzhou.handler.mybatisplus;  
  
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;  
import com.xinzhou.utils.SecurityUtils;  
import org.apache.ibatis.reflection.MetaObject;  
import org.springframework.stereotype.Component;  
  
import java.util.Date;  
  
/**  
 * @author 35238  
 * @date 2023/7/26 0026 20:52  
 */@Component  
//这个类是用来配置mybatis的字段自动填充。用于'发送评论'功能，由于我们在评论表无法对下面这四个字段进行插入数据  
//请求体提供下面四个参数，所以后端在往数据库插入数据时，下面四个字段是空值)，所有就需要这个类来帮助我们往下面这四个字段自动的插入值，  
//只要我们更新了评论表的字段，那么无法插入值的字段就自动有值了  
public class MyMetaObjectHandler implements MetaObjectHandler {  
  
    @Override  
    //只要对数据库执行了插入语句，那么就会执行到这个方法  
    public void insertFill(MetaObject metaObject) {  
        Long userId = null;  
        try {  
            //获取用户id  
            userId = SecurityUtils.getUserId();  
        } catch (Exception e) {  
            e.printStackTrace();  
            userId = -1L;//如果异常了，就说明该用户还没注册，我们就把该用户的userid字段赋值d为-1  
        }  
        //自动把下面四个字段新增了值。  
        this.setFieldValByName("createTime", new Date(), metaObject);  
        this.setFieldValByName("createBy",userId , metaObject);  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName("updateBy", userId, metaObject);  
    }  
  
    @Override  
    public void updateFill(MetaObject metaObject) {  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName(" ", SecurityUtils.getUserId(), metaObject);  
    }  
}
```
### 修改 Comment 类，增加了具体的自动填充规则
```java
package com.xinzhou.domain.pojo;  
  
import com.baomidou.mybatisplus.annotation.*;  
  
import java.io.Serializable;  
import java.util.Date;  
import lombok.Data;  
  
/**  
 * 评论表  
 * @TableName comment  
 */@TableName(value ="comment")  
@Data  
public class Comment implements Serializable {  
    /**  
     *     */  
    @TableId(type = IdType.AUTO)  
    private Long id;  
  
    /**  
     * 评论类型（0代表文章评论，1代表友链评论）  
     */  
    private String type;  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT)  
    private Long createBy;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT)  
    private Date createTime;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT_UPDATE)  
    private Long updateBy;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT_UPDATE)  
    private Date updateTime;  
  
    /**  
     * 删除标志（0代表未删除，1代表已删除）  
     */  
    private Integer delFlag;  
  
    @TableField(exist = false)  
    private static final long serialVersionUID = 1L;  
}
```
### 在 CommentServiceImpl 类，增加了发送评论的代码实现
```java
/**  
 * 添加评论  
 * @param comment  
 * @return  
 */  
@Override  
public ResponseResult addComment(Comment comment) {  
    //注意前端在调用这个发送评论接口时，在请求体是没有向我们传入createTime、createId、updateTime、updateID字段，所以  
    //我们这里往后端插入数据时，就会导致上面那行的四个字段没有值  
    //为了解决这个问题，我们在framework工程新增了MyMetaObjectHandler类、修改了Comment类  
    //限制用户在发送评论时，评论内容不能为空。如果为空就抛出异常  
    if(!StringUtils.hasText(comment.getContent()))  
        throw new SystemException(AppHttpCodeEnum.CONTENT_NOT_NULL);  
    //调用mybatisplus提供的save方法往数据库插入数据(用户发送的评论的各个字段)了  
    save(comment);  
    return ResponseResult.okResult();  
}
```
### 修改 CommentController 类，增加了发送评论的请求路径
```java
/**  
 * 发送评论  
 * @param comment  
 * @return  
 */  
package com.xinzhou.controller;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.service.CommentService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.*;  
  
@RestController  
@RequestMapping("/comment")  
public class CommentController {  
    @Autowired  
    private CommentService commentService;  
    @GetMapping("/commentList")  
    public ResponseResult commentList(Long articleId,Integer pageNum,Integer pageSize){  
        return commentService.commentList(articleId,pageNum,pageSize);  
    }  
  
    /**  
     * 发送评论  
     * @param comment  
     * @return  
     */  
    @PostMapping  
    public ResponseResult addComment(@RequestBody Comment comment){  
        return commentService.addComment(comment);  
    }  
}
```
# 友链评论列表
## 接口分析
用户登录后可以对友链发表评论，也可以对已有的评论进行回复

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/comment/linkCommentList|不需要 token 请求头|
- Query 格式请求参数：
```text
pageNum: 页码
pageSize: 每页条数
```
- 响应格式:
```json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "回复友链评论3",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:08:50",
                        "id": "23",
                        "rootId": "22",
                        "toCommentId": "22",
                        "toCommentUserId": "1",
                        "toCommentUserName": "sg333",
                        "username": "sg333"
                    }
                ],
                "content": "友链评论2",
                "createBy": "1",
                "createTime": "2022-01-30 10:08:28",
                "id": "22",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "sg333"
            }
        ],
        "total": "1"
    },
    "msg": "操作成功"
}
```
## 代码实现
修改SystemCanstants 类为如下，增加了区分文章、友链的评论类型
```java
package com.xinzhou.constants;  
  
public class SystemCanstants {  
  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
      
    /**  
     *  文章是正常发布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
  
    /**  
     * 分类为正常状态  
     */  
    public static final String STATUS_NORMAL = "0";  
  
    /**  
     * 友链状态为：审核通过  
     */  
    public static final String LINK_STATUS_NORMAL = "0";  
  
    /**  
     * 评论区的某条评论是根评论  
     */  
    public static final Long COMMENT_ROOT = -1L;  
    /**  
     * 评论类型为文章评论  
     */  
    public static final String ARTICLE_COMMENT = "0";  
    /**  
     * 评论类型为友链评论  
     */  
    public static final String LINK_COMMENT = "1";  
}
```
- 修改 CommentController
```java
package com.xinzhou.controller;  
  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.service.CommentService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.*;  
  
@RestController  
@RequestMapping("/comment")  
public class CommentController {  
    @Autowired  
    private CommentService commentService;  
  
    /**  
     * 查询评论列表  
     * @param articleId  
     * @param pageNum  
     * @param pageSize  
     * @return  
     */  
    @GetMapping("/commentList")  
    public ResponseResult commentList(Long articleId,Integer pageNum,Integer pageSize){  
        return commentService.commentList(SystemCanstants.ARTICLE_COMMENT,articleId,pageNum,pageSize);  
    }  
  
    /**  
     * 发送评论  
     * @param comment  
     * @return  
     */  
    @PostMapping  
    public ResponseResult addComment(@RequestBody Comment comment){  
        return commentService.addComment(comment);  
    }  
  
    /**  
     * 查询友链评论  
     * 增加了commentType参数，用于区分文章的评论区、友链的评论区  
     * @param pageNum  
     * @param pageSize  
     * @return  
     */  
    @GetMapping("/linkCommentList")  
    public ResponseResult linkCommentList(Integer pageNum,Integer pageSize){  
        return commentService.commentList(SystemCanstants.LINK_COMMENT,null,pageNum,pageSize);  
    }  
}
```
- 修改 CommentServiceImpl类
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.domain.vo.CommentVo;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import com.xinzhou.service.CommentService;  
import com.xinzhou.mapper.CommentMapper;  
import com.xinzhou.service.UserService;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
import org.springframework.util.StringUtils;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【comment(评论表)】的数据库操作Service实现  
* @createDate 2023-12-25 00:18:11  
*/  
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
    @Autowired  
    private UserService userService;  
  
    @Override  
    public ResponseResult commentList(String commentType, Long articleId, Integer pageNum, Integer pageSize) {  
  
        //查询对应文章的根评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        //对articleId进行判断,当评论类型为0（文章评论）时才进行判断  
        queryWrapper.eq(SystemCanstants.ARTICLE_COMMENT.equals(commentType),Comment::getArticleId,articleId);  
        //根评论的rootId为-1,SystemCanstants是我们写的解决字面值的类,COMMENT_ROOT标识评论为根评论  
        queryWrapper.eq(Comment::getRootId, SystemCanstants.COMMENT_ROOT);  
        //评论类型  
        queryWrapper.eq(Comment::getType,commentType);  
        //分页查询  
        Page<Comment> page = new Page<>(pageNum,pageSize);  
        page(page,queryWrapper);  
  
        //封装成CommentVo,  
        List<CommentVo> commentVos = toCommentVoList(page.getRecords());  
  
        //查询所有根评论对应的子评论集合，并赋值给对应的属性。  
        commentVos.stream()  
                .map( commentVo -> {  
                    //查询对应的子评论  
                    List<CommentVo> children = getChildren(commentVo.getId());  
                    //赋值  
                    commentVo.setChildren(children);  
                    return commentVo;  
                }).collect(Collectors.toList());  
  
  
        //封装成响应实体并返回  
        return ResponseResult.okResult(new PageVo(commentVos,page.getTotal()));  
    }  
  
    /**  
     * 添加评论  
     * @param comment  
     * @return  
     */  
    @Override  
    public ResponseResult addComment(Comment comment) {  
        //注意前端在调用这个发送评论接口时，在请求体是没有向我们传入createTime、createId、updateTime、updateID字段，所以  
        //我们这里往后端插入数据时，就会导致上面那行的四个字段没有值  
        //为了解决这个问题，我们在framework工程新增了MyMetaObjectHandler类、修改了Comment类  
        //限制用户在发送评论时，评论内容不能为空。如果为空就抛出异常  
        if(!StringUtils.hasText(comment.getContent()))  
            throw new SystemException(AppHttpCodeEnum.CONTENT_NOT_NULL);  
        //调用mybatisplus提供的save方法往数据库插入数据(用户发送的评论的各个字段)了  
        save(comment);  
        return ResponseResult.okResult();  
    }  
  
    /**  
     * 根据根评论的id查询对应子评论的集合  
     * @param id 根评论的id  
     * @return  
     */  
    private List<CommentVo> getChildren(Long id){  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(Comment::getRootId,id)  
                //对子评论按照时间进行排序  
                .orderByAsc(Comment::getCreateTime);  
        List<Comment> comments = list(queryWrapper);  
        //调用toCommentVoList,封装CommentVo  
        return toCommentVoList(comments);  
    }  
  
    /**  
     * 将封装CommentVo定义为方法调用  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
        //遍历vo集合  
        commentVos.stream()  
                .map(commentVo -> {  
                    //通过creatBy查询评论人的用户名  
                    String nickName = userService.getById(commentVo.getCreateBy()).getNickName();  
                    commentVo.setUsername(nickName);  
  
                    //通过toCommentUserId查询所评论的用户名昵称并赋值  
                    //如果toCommentUserId不为-1才进行查询，不为-1标识该评论不为根评论，有所回复的用户名  
                    if(!Objects.equals(commentVo.getToCommentUserId(), SystemCanstants.COMMENT_ROOT)){  
                        String toCommentUserName = userService.getById(commentVo.getToCommentUserId()).getNickName();  
                        commentVo.setToCommentUserName(toCommentUserName);  
                    }  
                    return commentVo;  
                }).collect(Collectors.toList());  
        return commentVos;  
    }  
}
```
# 个人信息
## 接口分析
进入个人中心的时候需要能够查看当前用户信息。请求不需要参数

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/user/userInfo|需要 token 请求头|
- 响应格式:
```json
{
	"code":200,
	"data":{
		"avatar":"头像的网络地址",
		"email":"123@qq.com",
		"id":"1",
		"nickName":"用户名",
		"sex":"1"
	},
	"msg":"操作成功"
}
```
## 代码实现 （UserServiceImpl）
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.UserService;  
import com.xinzhou.mapper.UserMapper;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.SecurityUtils;  
import org.springframework.stereotype.Service;  
  
/**  
* @author 14674  
* @description 针对表【sys_user(用户表)】的数据库操作Service实现  
* @createDate 2023-12-23 21:42:46  
*/  
@Service  
public class UserServiceImpl extends ServiceImpl<UserMapper, User>  
    implements UserService{  
  
    /**  
     * 个人信息查询  
     * @return  
     */  
    @Override  
    public ResponseResult userInfo() {  
  
        //获取当前用户id  
        Long userId = SecurityUtils.getUserId();  
        //根据用户id查询用户信息  
        User user = getById(userId);  
  
        //封装成UserInfoVo  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);  
        return ResponseResult.okResult(userInfoVo);  
    }  
}
```
# 文件上传（七牛云）
## 七牛云测试代码编写
- 查看 AK、SK 
![[Pasted image 20231227001457.png]]
- 阅读七牛云 SDK
![[Pasted image 20231227001218.png]]
- 示例代码
![[Pasted image 20231227001250.png]]
- 导入依赖
```xml
<dependency> 
	<groupId>com.qiniu</groupId> 
	<artifactId>qiniu-java-sdk</artifactId> 
	<version>[7.13.0, 7.13.99]</version>
</dependency>
```
- 测试实例
```java
package com.xinzhou;  
  
import com.google.gson.Gson;  
import com.qiniu.common.QiniuException;  
import com.qiniu.http.Response;  
import com.qiniu.storage.Configuration;  
import com.qiniu.storage.Region;  
import com.qiniu.storage.UploadManager;  
import com.qiniu.storage.model.DefaultPutRet;  
import com.qiniu.util.Auth;  
import org.junit.jupiter.api.Test;  
import org.springframework.boot.context.properties.ConfigurationProperties;  
import org.springframework.boot.test.context.SpringBootTest;  
  
import java.io.ByteArrayInputStream;  
import java.io.FileInputStream;  
import java.io.InputStream;  
import java.io.UnsupportedEncodingException;  
/**  
 * 七牛云测试  
 */  
@SpringBootTest(classes = MyBlogApplication.class)  
@ConfigurationProperties(prefix = "oss")//指定读取application.yml文件的myoss属性的数据  
public class OSSTest {  
  
    //注意要从application.yml读取属性数据，下面的3个成员变量的名字必须对应application.yml的myoss属性的三个子属性名字  
    private String accessKey;  
    private String secretKey;  
    private String bucket;  
  
    public void setAccessKey(String accessKey) {  
        this.accessKey = accessKey;  
    }  
  
    public void setSecretKey(String secretKey) {  
        this.secretKey = secretKey;  
    }  
  
    public void setBucket(String bucket) {  
        this.bucket = bucket;  
    }  
  
    @Test  
    public void testOSS(){  
        //构造一个带指定 Region 对象的配置类  
        Configuration cfg = new Configuration(Region.autoRegion());  
        cfg.resumableUploadAPIVersion = Configuration.ResumableUploadAPIVersion.V2;// 指定分片上传版本  
//...其他参数参考类注释  
  
        UploadManager uploadManager = new UploadManager(cfg);  
//...生成上传凭证，然后准备上传  
        //为避免暴露信息，我们会把信息写到application.yml里面，然后添加ConfigurationProperties注解、3个成员变量即可读取  
//        String accessKey = "your access key";  
//        String secretKey = "your secret key";  
//        String bucket = "xinzhou-blog";  
  
//默认不指定key的情况下，以文件内容的hash值作为文件名  
//可以指定上传文件夹
        String key = null;  
  
        try {  
//            byte[] uploadBytes = "hello qiniu cloud".getBytes("utf-8");  
//            ByteArrayInputStream byteInputStream=new ByteArrayInputStream(uploadBytes);  
  
            //上面两行是官方写的(注释掉)，下面那几行是我们写的  
            InputStream inputStream = new FileInputStream("C:\\Users\\14674\\Desktop\\test.svg");  
            Auth auth = Auth.create(accessKey, secretKey);  
            String upToken = auth.uploadToken(bucket);  
  
            try {  
                Response response = uploadManager.put(inputStream,key,upToken,null, null);  
                //解析上传成功的结果  
                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);  
                System.out.println(putRet.key);  
                System.out.println(putRet.hash);  
            } catch (QiniuException ex) {  
                ex.printStackTrace();  
                if (ex.response != null) {  
                    System.err.println(ex.response);  
  
                    try {  
                        String body = ex.response.toString();  
                        System.err.println(body);  
                    } catch (Exception ignored) {  
                    }  
                }  
            }  
        } catch (Exception ex) {  
            //ignore  
        }  
  
    }  
}
```
- 测试文件上传
![[Pasted image 20231227001611.png]]
## 接口分析
在个人中心点击编辑的时候可以上传头像图片。上传完头像后，可以用于更新个人信息接口

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/upload|需要 token|
- 参数:
Img，值为要上传的文件
- 请求头：
Content-Type ：multipart/form-data;
- 响应格式:
```json
{
    "code": 200,
    "data": "文件的访问网址",
    "msg": "操作成功"
}
```
## 代码实现
### PathUtils 工具类：把某个文件名重命名为我们指定的文件名，且修改文件存放路径
```java
package com.xinzhou.utils;  
  
import java.text.SimpleDateFormat;  
import java.util.Date;  
import java.util.UUID;  
  
/**  
 * @author xinzhou  
 * @date 2023/7/29 0029 12:45  
 *///对原始文件名进行修改文件名，并修改存放目录  
public class PathUtils {  
  
    public static String generateFilePath(String fileName){  
        //根据日期生成路径   2022/1/15/        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd/");  
        String datePath = sdf.format(new Date());  
        //uuid作为文件名  
        String uuid = UUID.randomUUID().toString().replaceAll("-", "");  
        //后缀和文件后缀一致  
        int index = fileName.lastIndexOf(".");  
        // test.jpg -> .jpg  
        String fileType = fileName.substring(index);  
        return new StringBuilder().append(datePath).append(uuid).append(fileType).toString();  
    }  
}
```
### OssUploadServiceImpl 实现类
```java
package com.xinzhou.service.impl;  
  
import com.google.gson.Gson;  
import com.qiniu.common.QiniuException;  
import com.qiniu.http.Response;  
import com.qiniu.storage.Configuration;  
import com.qiniu.storage.Region;  
import com.qiniu.storage.UploadManager;  
import com.qiniu.storage.model.DefaultPutRet;  
import com.qiniu.util.Auth;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import com.xinzhou.service.UploadService;  
import com.xinzhou.utils.PathUtils;  
import lombok.Data;  
import org.springframework.boot.context.properties.ConfigurationProperties;  
import org.springframework.stereotype.Service;  
import org.springframework.web.multipart.MultipartFile;  
  
import java.io.InputStream;  
  
@Service  
@Data  
@ConfigurationProperties(prefix = "oss")  
public class OssUploadService implements UploadService {  
    @Override  
    public ResponseResult uploadImg(MultipartFile img) {  
  
        // 判断文件类型  
        //获取原始文件名  
        String originalFilename = img.getOriginalFilename();  
        //对原始文件名进行判断  
        if(!originalFilename.endsWith(".png") && !originalFilename.endsWith(".jpg")){  
            throw new SystemException(AppHttpCodeEnum.File_TYPE_ERROR);  
        }  
  
        //如果判断通过上传到OSS  
        String filePath = PathUtils.generateFilePath(originalFilename);  
        String url = uploadOss(img,filePath);  
        return ResponseResult.okResult(url);  
    }  
  
  
    private String accessKey;  
    private String secretKey;  
    private String bucket;  
  
    /**  
     * 上传文件到七牛云  
     */  
    private String uploadOss(MultipartFile imgFile, String filePath){  
        //构造一个带指定 Region 对象的配置类  
        Configuration cfg = new Configuration(Region.autoRegion());  
        cfg.resumableUploadAPIVersion = Configuration.ResumableUploadAPIVersion.V2;// 指定分片上传版本  
//...其他参数参考类注释  
  
        UploadManager uploadManager = new UploadManager(cfg);  
        //默认不指定key的情况下，以文件内容的hash值作为文件名  
        //可以指定上传文件夹  
        String key = filePath;  
        try {  
            //把传过来的参数文件转换为inputStream  
            InputStream inputStream = imgFile.getInputStream();  
            Auth auth = Auth.create(accessKey, secretKey);  
            String upToken = auth.uploadToken(bucket);  
  
            try {  
                Response response = uploadManager.put(inputStream,key,upToken,null, null);  
                //解析上传成功的结果  
                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);  
                System.out.println(putRet.key);  
                System.out.println(putRet.hash);  
                //返回文件路径，域名可以放到配置文件中动态获取  
                return "http://s6a63kkm8.hn-bkt.clouddn.com/"+key;  
            } catch (QiniuException ex) {  
                ex.printStackTrace();  
                if (ex.response != null) {  
                    System.err.println(ex.response);  
  
                    try {  
                        String body = ex.response.toString();  
                        System.err.println(body);  
                    } catch (Exception ignored) {  
                    }  
                }  
            }  
        } catch (Exception ex) {  
            //ignore  
        }  
        return "上传失败";  
    }  
}
```
# 更新个人信息
## 接口分析
在编辑完个人资料后点击保存会对个人资料进行更新。

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|PUT|/user/userInfo|需要 token 请求头|
- 请求体中 json 格式数据：
```json
{
    "avatar":"图片url地址",
    "email":"23412332@qq.com",
    "id":"1",
    "nickName":"用户昵称",
    "sex":"1"
}
```
- 响应格式:
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
```java
/**  
 * 更新个人信息  
 * @param user  
 * @return  
 */  
@Override  
public ResponseResult updateUserInfo(User user) {  
    updateById(user);  
    return ResponseResult.okResult();  
}
```
# 注册功能
## 接口设计
要求用户能够在注册界面完成用户的注册。要求用户名，昵称，邮箱不能和数据库中原有的数据重复。如果某项重复了注册失败并且要有对应的提示。并且要求用户名，密码，昵称，邮箱都不能为空。
注意:密码必须密文存储到数据库中

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/user/register|不需要 token 请求头|
- 请求体：
```json
{
  "email": "string",
  "nickName": "string",
  "password": "string",
  "userName": "string"
}
```
- 响应格式:
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
### AppHttpCodeEnum 枚举类修改为如下
```java
package com.xinzhou.enums;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:52  
 */public enum AppHttpCodeEnum {  
    // 成功  
    SUCCESS(200,"操作成功"),  
    // 登录  
    NEED_LOGIN(401,"需要登录后操作"),  
    NO_OPERATOR_AUTH(403,"无权限操作"),  
    SYSTEM_ERROR(500,"出现错误"),  
    USERNAME_EXIST(501,"用户名已存在"),  
    PHONENUMBER_EXIST(502,"手机号已存在"),  
    EMAIL_EXIST(503, "邮箱已存在"),  
    REQUIRE_USERNAME(504, "必需填写用户名"),  
    LOGIN_ERROR(505,"用户名或密码错误"),  
    File_TYPE_ERROR(507,"文件类型错误，请上传png或jpg文件"),  
    USERNAME_NOT_NULL(508,"用户名不能为空"),  
    NICKNAME_NOT_NULL(509,"昵称不能为空"),  
    PASSWORD_NOT_NULL(510,"密码不能为空"),  
    EMAIL_NOT_NULL(511,"Email不能为空"),  
    NICKNAME_EXIST(512,"昵称已存在"),  
    CONTENT_NOT_NULL(506,"评论内容不能为空");  
    int code;  
    String msg;  
  
    AppHttpCodeEnum(int code, String errorMessage){  
        this.code = code;  
        this.msg = errorMessage;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
}
```
### UserServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import com.xinzhou.service.UserService;  
import com.xinzhou.mapper.UserMapper;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.SecurityUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.stereotype.Service;  
import org.springframework.util.StringUtils;  
  
/**  
* @author 14674  
* @description 针对表【sys_user(用户表)】的数据库操作Service实现  
* @createDate 2023-12-23 21:42:46  
*/  
@Service  
public class UserServiceImpl extends ServiceImpl<UserMapper, User>  
    implements UserService{  
  
    /**  
     * 个人信息查询  
     * @return  
     */  
    @Override  
    public ResponseResult userInfo() {  
  
        //获取当前用户id  
        Long userId = SecurityUtils.getUserId();  
        //根据用户id查询用户信息  
        User user = getById(userId);  
  
        //封装成UserInfoVo  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);  
        return ResponseResult.okResult(userInfoVo);  
    }  
  
    /**  
     * 更新个人信息  
     * @param user  
     * @return  
     */  
    @Override  
    public ResponseResult updateUserInfo(User user) {  
        updateById(user);  
        return ResponseResult.okResult();  
    }  
  
    //解密和加密用的这套算法。我们在huanf-blog工程的securityConfig类里面覆盖过PasswordEncoder这个bean  
    @Autowired  
    private PasswordEncoder passwordEncoder;  
    /**  
     * 用户注册  
     * @param user  
     * @return  
     */  
    @Override  
    public ResponseResult register(User user) {  
        //对数据进行非空判断  
        if(!StringUtils.hasText(user.getUserName())){  
            throw new SystemException(AppHttpCodeEnum.USERNAME_NOT_NULL);  
        }  
        if(!StringUtils.hasText(user.getPassword())){  
            throw new SystemException(AppHttpCodeEnum.PASSWORD_NOT_NULL);  
        }  
        if(!StringUtils.hasText(user.getNickName())){  
            throw new SystemException(AppHttpCodeEnum.NICKNAME_NOT_NULL);  
        }  
        if(!StringUtils.hasText(user.getEmail())){  
            throw new SystemException(AppHttpCodeEnum.EMAIL_NOT_NULL);  
        }  
  
        //对数据进行是否存在的判断  
        if(userNameExit(user.getUserName())){  
            throw new SystemException(AppHttpCodeEnum.USERNAME_EXIST);  
        }  
        if(nickNameExit(user.getNickName())){  
            throw new SystemException(AppHttpCodeEnum.NICKNAME_EXIST);  
        }  
        if(emailExit(user.getEmail())){  
            throw new SystemException(AppHttpCodeEnum.EMAIL_EXIST);  
        }  
  
        //对密码进行加密  
        String encodePassword = passwordEncoder.encode(user.getPassword());  
        user.setPassword(encodePassword);  
        //存入数据库  
        save(user);  
        return ResponseResult.okResult();  
    }  
  
    private boolean emailExit(String email) {  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getEmail,email);  
        return count(queryWrapper)>0;  
    }  
  
    private boolean nickNameExit(String nickName) {  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getNickName,nickName);  
        return count(queryWrapper)>0;  
    }  
  
    private boolean userNameExit(String userName) {  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getUserName,userName);  
        return count(queryWrapper)>0;  
    }  
}
```
# 日志记录
## 需求分析
需要通过日志记录接口调用信息。便于后期调试排查。并且可能有很多接口都需要进行日志的记录。接口被调用时日志打印格式如下:
```java
log.info("======================Start======================");
// 打印请求 URL
log.info("请求URL   : {}",);
// 打印描述信息
log.info("接口描述   : {}", );
// 打印 Http method
log.info("请求方式   : {}", );
// 打印调用 controller 的全路径以及执行方法
log.info("请求类名   : {}.{}", );
// 打印请求的 IP
log.info("访问IP    : {}",);
// 打印请求入参
log.info("传入参数   : {}",);
// 打印出参
log.info("返回参数   : {}", );
// 结束后换行
log.info("=======================end=======================" + System.lineSeparator());
```
相当于是对原有的功能进行增强。并且是批量的增强，这个时候就非常适合用 AOP 来进行实现，不对业务代码进行侵入，完全解耦
## AOP 实现日志记录的分析
定义切面类，在切面类通过 '切点表达式' 或 '自定义注解'，来指定切点
切面类: 指定要增强哪个切点，里面写通知的方法，通知的方法里面写具体的增强代码
AOP 中的通知方法有五种，如下

|   |   |
|---|---|
|通知方法|描述|
|前置通知|在一个方法执行之前的阶段，执行通知。可以在目标方法执行前做一些预处理操作|
|后置通知|在一个方法执行之后的阶段，执行通知。通常用于执行一些清理操作或日志记录|
|异常通知|在方法抛出异常退出时执行的通知。用于处理目标方法抛出的异常情况|
|最终通知|无论目标方法是否成功执行，最终通知总会被执行，常用于释放资源|
|环绕通知|环绕通知是 AOP 中最灵活的通知类型。能在目标方法前后完全控制连接点，决定是否执行目标方法并进行额外处理|
## AOP 实现日志记录的代码
### 在 framework 工程的 pom.xml 添加如下依赖
```xml
<!--AOP-->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```
### 新建 annotation.mySystemlog 接口
```java
package com.xinzhou.annotation;  
  
import org.aspectj.lang.annotation.Around;  
  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
  
@Retention(RetentionPolicy.RUNTIME)//表示Systemlog注解类会保持到runtime阶段  
@Target({ElementType.METHOD})//表示mySystemlog注解类的注解功能只能用于方法上  
//'自定义注解'类，以后就可以使用@mySystemlog注解了，注解名就是下面那行的接口名  
public @interface SystemLog {  
  
    //为controller提供接口的描述信息，用于'日志记录'功能  
    String businessName();  
}
```
### 新建 aspect. LogAspect 类
```java
package com.xinzhou.aspect;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.annotation.SystemLog;  
import lombok.extern.slf4j.Slf4j;  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.Signature;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Pointcut;  
import org.aspectj.lang.reflect.MemberSignature;  
import org.aspectj.lang.reflect.MethodSignature;  
import org.springframework.stereotype.Component;  
import org.springframework.web.context.request.RequestAttributes;  
import org.springframework.web.context.request.RequestContextHolder;  
import org.springframework.web.context.request.ServletRequestAttributes;  
  
import javax.servlet.http.HttpServletRequest;  
  
@Component  
@Aspect//告诉spring容器，myLogAspect是切面类  
@Slf4j  
public class LogAspect {  
  
  
    @Pointcut("@annotation(com.xinzhou.annotation.SystemLog)")  
    //确定哪个切点，以后哪个类想成为切点，就在哪个类添加上面那行的注解。例如下面这个pt()就是切点  
    public void pt(){  
  
    }  
  
    //定义通知的方法(这里用的是环绕通知)，通知的方法也就是增强的具体代码。@Around注解表示该通知的方法会用在哪个切点  
    @Around("pt()")  
    //ProceedingJoinPoint可以拿到被增强方法的信息  
    public Object printLog(ProceedingJoinPoint joinPoint) throws Throwable{  
  
        Object ret;  
        try {  
            handleBefore(joinPoint);  
            //proceed方法表示调用目标方法，ret就是目标方法执行完之后的返回值  
            ret = joinPoint.proceed();  
            //调用下面写的'实现打印日志信息的数据信息'的方法  
            handleAfter(ret);  
        } finally {  
            // 结束后换行  
            log.info("=======================end=======================" + System.lineSeparator());  
        }  
  
        return ret;  
    }  
  
    //上面的xxprintLog方法执行之后会去调用下面这个xxhandleAfter方法  
    private void handleAfter(Object ret) {  
        // 打印出参。JSON.toJSONString十FastJson提供的工具方法，能把数组转成JSON  
        log.info("返回参数   : {}", JSON.toJSONString(ret));  
    }  
  
    /**  
     * 上面的printLog方法执行之前会去调用下面这个handleBefore方法  
     */  
    private void handleBefore(ProceedingJoinPoint joinPoint) {  
        //ServletRequestAttributes是RequestAttributes是spring接口的实现类  
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();  
        //下面那行就可以拿到请求的报文了，其中有我们需要的url、请求方式、ip。这里拿到的request会在下面的log中大量使用  
        HttpServletRequest request = requestAttributes.getRequest();  
  
        //获取被增强方法上的注解对象，如获取UserController类的updateUserInfo方法上一行的@mySystemlog注解  
        SystemLog systemLog = getSystemLog(joinPoint);  
  
  
        log.info("======================Start======================");  
        // 打印请求 URL        log.info("请求URL   : {}",request.getRequestURL());  
        // 打印描述信息  
        log.info("接口描述   : {}", systemLog.businessName());  
        // 打印 Http method        log.info("请求方式   : {}",request.getMethod());  
        // 打印调用 controller 的全路径以及执行方法  
        log.info("请求类名   : {}.{}",joinPoint.getSignature().getDeclaringTypeName(),((MethodSignature) joinPoint.getSignature()).getName());  
        // 打印请求的 IP        log.info("访问IP    : {}",request.getRemoteHost());  
        // 打印请求入参,JSON.toJSONString是FastJson提供的工具方法，能把数组转成JSON  
        log.info("传入参数   : {}", JSON.toJSONString(joinPoint.getArgs()));  
    }  
  
    //获取被增强方法的注解对象，例如获取UserController类的updateUserInfo方法上一行的@mySystemlog注解  
    private SystemLog getSystemLog(ProceedingJoinPoint joinPoint) {  
        //Signature是spring提供的接口，MethodSignature是Signature的子接口  
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();  
        //SystemLog是我们写的自定义注解的接口  
        //下面那行就能获取被增强方法的注解对象，例如获取UserController类的updateUserInfo方法上一行的@Systemlog注解  
        SystemLog annotation = methodSignature.getMethod().getAnnotation(SystemLog.class);  
        return annotation;  
    }  
}
```
### 修改 UserController 类
```java
@PutMapping("/userInfo")  
@SystemLog(businessName = "更新用户信息")  
public ResponseResult updateUserInfo(@RequestBody User user){  
    return userService.updateUserInfo(user);  
}
```
- 可以修改 application. Yml ，注释掉 mybatisplus 的日志信息，避免对我们的日志信息造成干扰
# 浏览次数
## 思路分析
在用户浏览博文时要实现对应博客浏览量的增加。我们只需要在每次用户浏览博客时更新对应的浏览数即可
但是如果直接操作博客表的浏览量的话，在并发量大的情况下会出现什么问题呢？如何去优化呢？如下四点
①在应用启动时把博客的浏览量存储到redis中 - 项目启动的预处理功能
②更新浏览量时去更新redis中的数据
③每隔3分钟把Redis中的浏览量更新到数据库中 - 定时任务功能
④读取文章浏览量时从redis读取
在实现 '浏览次数' 功能之前，我们先学习一下必要的基础知识，如下
## 基础-启动预处理
如果希望在 SpringBoot 应用启动时进行一些初始化操作可以选择使用 CommandLineRunner 接口来进行处理。
我们只需要实现CommandLineRunner接口，并且把对应的bean注入容器。把相关初始化的代码重新到需要重新的方法中。
这样就会在应用启动的时候执行对应的代码。
```java
package com.xinzhou.runner;  
  
import org.springframework.boot.CommandLineRunner;  
import org.springframework.stereotype.Component;  
  
@Component  
//项目启动时，该类负责预处理一些代码。CommandLineRunner是spring提供的接口  
public class TestRunner implements CommandLineRunner {  
    @Override  
    public void run(String... args) throws Exception {  
        System.out.println("程序初始化");  
    }  
}
```
## 基础-定时任务
定时任务的实现方式有很多，比如 XXL-Job 等。但是其实核心功能和概念都是类似的，很多情况下只是调用的 API 不同而已
这里就先用 SpringBoot 为我们提供的定时任务的 API 来实现一个简单的定时任务，先对定时任务里面的一些核心概念有个大致的了解
实现步骤：
1. 在配置类上使用@EnableScheduling 注解，就能开启定时任务功能
```java
package com.xinzhou;  
  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
import org.springframework.scheduling.annotation.EnableScheduling;  
  
@SpringBootApplication  
@MapperScan("com.xinzhou.mapper")  
@EnableScheduling  
public class MyBlogApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(MyBlogApplication.class, args);  
    }  
}
```
2. 配置定时任务执行代码，并配置任务执行时间
```java
package com.xinzhou.cronjob;  
  
import org.springframework.scheduling.annotation.Scheduled;  
import org.springframework.stereotype.Component;  
  
import java.time.LocalTime;  
  
@Component  
public class TestJob {  
  
    @Scheduled(cron = "0/5 * * * * ?")//在哪个方法添加了@Scheduled注解，哪个方法就会定时去执行  
    //上面那行@Scheduled注解的cron属性就是具体的定时规则。从每一分钟的0秒开始，每隔5秒钟就会执行下面那行的testJob()方法  
    public void testJob(){  
        //要执行的代码  
        System.out.println("定时任务执行了，现在的时间是: "+ LocalTime.now());  
    }  
}
```
## 基础-cron 表达式
cron 表达式是用来设置定时任务执行时间的表达式。不会写的话，去这个 cron 表达式生成器网站 -> [https://www.bejson.com/othertools/cron/](https://www.bejson.com/othertools/cron/)
cron 表达式由七部分组成，中间由空格分隔，这七部分从左往右依次是:
```txt
秒(0~59)，分钟(0~59)，小时(0~23)，日期(1-月最后一天)，月份(1-12)，星期几(1-7,1表示星期日)，年份(可不写)
```
## 接口分析
在用户浏览博文时要实现对应博客浏览量的增加。我们只需要在每次用户浏览博客时更新对应的浏览数即可

| 请求方式 | 请求地址 | 请求头 |
| ---- | ---- | ---- |
| PUT | /article/updateViewCount/{id} | 不需要 token 请求头 |
参数: 请求路径中携带文章 id
响应格式:
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
