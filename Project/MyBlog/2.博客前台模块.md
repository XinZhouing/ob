# 文章列表
## 表分析
![[Pasted image 20231221205536.png]]
## 热门文章接口分析
需要查询浏览量最高的前10篇文章的信息。要求展示文章标题和浏览量。把能让用户自己点击跳转到具体的文章详情进行浏览
注意：不能把草稿展示出来，不能把删除了的文章查询出来。要按照浏览量进行降序排序
## 统一响应格式
在公共模块下新建枚举类和响应实体类
```java
package com.xinzhou.enums;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:52  
 */public enum AppHttpCodeEnum {  
    // 成功  
    SUCCESS(200,"操作成功"),  
    // 登录  
    NEED_LOGIN(401,"需要登录后操作"),  
    NO_OPERATOR_AUTH(403,"无权限操作"),  
    SYSTEM_ERROR(500,"出现错误"),  
    USERNAME_EXIST(501,"用户名已存在"),  
    PHONENUMBER_EXIST(502,"手机号已存在"),  
    EMAIL_EXIST(503, "邮箱已存在"),  
    REQUIRE_USERNAME(504, "必需填写用户名"),  
    LOGIN_ERROR(505,"用户名或密码错误");  
    int code;  
    String msg;  
  
    AppHttpCodeEnum(int code, String errorMessage){  
        this.code = code;  
        this.msg = errorMessage;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
}
```
```java
package com.xinzhou.domain;  
  
import com.fasterxml.jackson.annotation.JsonInclude;  
import com.xinzhou.enums.AppHttpCodeEnum;  
  
import java.io.Serializable;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:49  
 *///统一响应格式。实体类，或者这个类严格来说叫响应体  
@JsonInclude(JsonInclude.Include.NON_NULL)  
public class ResponseResult<T> implements Serializable {  
    private Integer code;  
    private String msg;  
    private T data;  
  
    public ResponseResult() {  
        this.code = AppHttpCodeEnum.SUCCESS.getCode();  
        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();  
    }  
  
    public ResponseResult(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg, T data) {  
        this.code = code;  
        this.msg = msg;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
    }  
  
    public static ResponseResult errorResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.error(code, msg);  
    }  
    public static ResponseResult okResult() {  
        ResponseResult result = new ResponseResult();  
        return result;  
    }  
    public static ResponseResult okResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.ok(code, null, msg);  
    }  
  
    public static ResponseResult okResult(Object data) {  
        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());  
        if(data!=null) {  
            result.setData(data);  
        }  
        return result;  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums){  
        return setAppHttpCodeEnum(enums,enums.getMsg());  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){  
        return setAppHttpCodeEnum(enums,msg);  
    }  
  
    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){  
        return okResult(enums.getCode(),enums.getMsg());  
    }  
  
    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){  
        return okResult(enums.getCode(),msg);  
    }  
  
    public ResponseResult<?> error(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data, String msg) {  
        this.code = code;  
        this.data = data;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(T data) {  
        this.data = data;  
        return this;  
    }  
  
    public Integer getCode() {  
        return code;  
    }  
  
    public void setCode(Integer code) {  
        this.code = code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
  
    public T getData() {  
        return data;  
    }  
  
    public void setData(T data) {  
        this.data = data;  
    }  
  
}
```
## 代码实现
- 在 ArticleServiceImpl 中实现 hotArticleList 方法
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    return ResponseResult.okResult(articles);  
}
```
## 测试接口
访问： http://localhost:7777/article/hotArticleList 
![[Pasted image 20231221213915.png]]
## 后端解决跨域
```java
package com.xinzhou.config;  
  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.servlet.config.annotation.CorsRegistry;  
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  
  
@Configuration  
public class WebConfig implements WebMvcConfigurer {  
  
    @Override  
    public void addCorsMappings(CorsRegistry registry) {  
        // 设置允许跨域的路径  
        registry.addMapping("/**")  
                // 设置允许跨域请求的域名  
                .allowedOriginPatterns("*")  
                // 是否允许cookie  
                .allowCredentials(true)  
                // 设置允许的请求方式  
                .allowedMethods("GET", "POST", "DELETE", "PUT")  
                // 设置允许的header属性  
                .allowedHeaders("*")  
                // 跨域允许时间  
                .maxAge(3600);  
    }  
  
}
```
## 前端项目的启动
	npm install
	npm run dev
- 前后端联调
![[Pasted image 20231221220012.png]]
## 优化
- VO 优化
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    //bean拷贝  
    List<HotArticleVo> articleVos = new ArrayList<>();  
    for(Article article : articles){  
        HotArticleVo vo = new HotArticleVo();  
        BeanUtils.copyProperties(article,vo);  
        articleVos.add(vo);  
    }  
  
    return ResponseResult.okResult(articleVos);  
}
```
- 字面值处理
	实际项目中都不允许直接在代码中使用字面值 (代码中的固定值)。都需要定义成常量来使用。这种方式有利于提高代码的可维护性。
```java
package com.xinzhou.constants;  
  
public class SystemCanstants {  
  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
      
    /**  
     *  文章是正常分布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
      
}
```
优化后：
```java
//必须是正式文章  
queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);
```
- Bean 拷贝的封装
```java
package com.xinzhou.utils;  
  
import org.springframework.beans.BeanUtils;  
import java.util.List;  
import java.util.stream.Collectors;  
  
public class BeanCopyUtils {  
    private BeanCopyUtils(){  
    }  
  
    public static <V> V copyBean(Object source,Class<V> clazz) {  
        //创建目标对象  
        V result = null;  
        try {  
            result = clazz.newInstance();  
            //实现属性拷贝  
            BeanUtils.copyProperties(source, result);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        //返回结果  
        return result;  
    }  
  
    public static <O,V> List<V> copyBeanList(List<O> list,Class<V> clazz){  
        return list.stream()  
                .map(o -> copyBean(o, clazz))  
                .collect(Collectors.toList());  
    }  
}
```
优化后：
```java
//bean拷贝  
List<HotArticleVo> articleVos = BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);
```
- 测试
![[Pasted image 20231221222806.png]]
# 分类列表
## 表分析
![[Pasted image 20231221223044.png]]
## 需求分析
	页面上需要展示分类列表，用户可以点击具体的分类查看该分类下的文章列表。要求只展示有发布正式文章的分类 。要求必须是正常(非禁用)状态的分类
## 代码实现
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Article;  
import com.xinzhou.domain.pojo.Category;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.service.ArticleService;  
import com.xinzhou.service.CategoryService;  
import com.xinzhou.mapper.CategoryMapper;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Set;  
import java.util.function.Function;  
import java.util.function.Predicate;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【category(分类表)】的数据库操作Service实现  
* @createDate 2023-12-21 22:39:08  
*/  
@Service  
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService{  
  
    @Autowired  
    private ArticleService articleService;  
    @Override  
    public ResponseResult getCategoryList() {  
        //查询状态为已发布的文章表  
        LambdaQueryWrapper<Article> articleWrapper = new LambdaQueryWrapper<>();  
        articleWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
        List<Article> articleList = articleService.list(articleWrapper);  
        //获取文章的categoryId并去重  
        Set<Long> categoryIds = articleList.stream()  
                .map(Article::getCategoryId)  
                .collect(Collectors.toSet());  
        //查询分类状态为正常状态的分类表  
        List<Category> categories = listByIds(categoryIds);  
  
        categories = categories.stream()  
                .filter(category -> SystemCanstants.STATUS_NORMAL.equals(category.getStatus()))  
                .collect(Collectors.toList());  
        //封装vo  
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(categories, CategoryVo.class);  
        return ResponseResult.okResult(categoryVos);  
    }  
}
```
# 分页查询文章列表
## 接口分析
	首页需要查询所有的文章列表。分类页面需要查询对应分类下的文章列表。只能查询正式发布的文章，置顶的文章要显示在最前面
## 代码实现
	在公共模块的config 目录新建 MybatisPlusConfig 类，作用是配置 MyBatisPlus 的分页插件，不然分页没有效果
```java
package com.xinzhou.config;  
  
import com.baomidou.mybatisplus.annotation.DbType;  
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
@Configuration  
@MapperScan("com.xinzhou.mapper")  
public class MyBatisPlusConfig {  
  
    /**  
     * 配置分页插件  
     * @return  
     */  
    @Bean  
    public MybatisPlusInterceptor mybatisPlusInterceptor(){  
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();  
        //如果配置多个插件,切记分页最后添加  
        //如果有多数据源可以不配具体类型 否则都建议配上具体的DbType  
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));  
        return interceptor;  
    }  
}
```
	新建 PageVo 实体类，用于封装返回分页的数据
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.List;  
  
/**  
 * 封装返回分页的数据  
 */  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class PageVo {  
  
    private List rows;  
  
    private Long total;  
}
```
	解决问题：categoryName字段没有返回值，使用stream流，从article表中获取categoryId用于查询categoryName设置到Article对象中（在Article实体类中加入categoryName字段，并使用@TableFiled注释标识为数据库中不存在）
```java
@Override  
public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {  
    //条件：有categoryId查询时要传入相同的，状态是正式发布的，对isTop进行降序排序  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Objects.nonNull(categoryId)&&categoryId>0,Article::getCategoryId,categoryId);  
    queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
    queryWrapper.orderByDesc(Article::getIsTop);  
  
    //分页查询  
    Page<Article> page = new Page<>(pageNum,pageSize);  
    page(page,queryWrapper);  
  
    //解决：查询categoryName为null问题，通过articleId去查询articleName进行设置  
    List<Article> articles = page.getRecords();  
    articles.stream()  
            .map(article -> {  
                //简化为一行：可以使用Lombok中@Accessors（chain=ture）注释Article实体类，可以将类中set方法的返回值设置为该类  
                article.setCategoryName(categoryService.getById(article.getCategoryId()).getName());  
                return article;  
            })  
            .collect(Collectors.toList());  
  
    //封装vo  
    List<ArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(page.getRecords(), ArticleListVo.class);  
  
    PageVo pageVo = new PageVo(articleListVos, page.getTotal());  
  
    return ResponseResult.okResult(pageVo);  
}
```
## FastJson 配置
	由于ArticleListVO类的createTime成员变量是Date类型，默认是由java的Jackson来处理，使用 ISO-8601 规范来处理日期时间格式。ISO-8601 是一种国际标准的日期时间表示法，例如："2023-07-21T06:53:24"。我们不希望时间被处理成这种格式。解决: 在WebConfig中配置使用FastJson 
```java
/**  
 * FastJson配置：时间格式问题  
 */  
@Bean//使用@Bean注入fastJsonHttpMessageConvert  
public HttpMessageConverter fastJsonHttpMessageConverters() {  
    //1.需要定义一个Convert转换消息的对象  
    FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();  
    FastJsonConfig fastJsonConfig = new FastJsonConfig();  
    fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);  
    fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");  
  
    SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);  
  
    fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);  
    fastConverter.setFastJsonConfig(fastJsonConfig);  
    HttpMessageConverter<?> converter = fastConverter;  
    return converter;  
}  
  
@Override  
//配置消息转换器  
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {  
    //增加我们的消息转换器  
    converters.add(fastJsonHttpMessageConverters());  
}
```
# 文章详情接口
## 接口分析
	要求在文章列表点击阅读全文时能够跳转到文章详情页面，可以让用户阅读文章正文。并且要在文章详情中展示其分类名。响应格式：
```json
{
  "code": 200,
  "data": {
    "categoryId": "1",
    "categoryName": "java",
    "content": "文章详情的具体文章内容",
    "createTime": "2022-01-23 23:20:11",
    "id": "1",
    "isComment": "0",
    "title": "SpringSecurity从入门到精通",
    "viewCount": "114"
  },
  "msg": "操作成功"
}
```
## 常用的 HTTP 请求形式
	以 GET /article/{id} 为例的路径参数形式，下面两种是比较常用的。不常用的有'请求体形式'、'请求头形式'

|   |   |   |
|---|---|---|
|请求形式|示例|描述|
|路径参数形式|/articles/{id}|参数作为路径的一部分，表示明确的资源标识符或必需的参数。|
|查询参数形式|/articles?id=1&num=1|参数通过 "?" 或 "&" 的方式附加在 URL 的末尾，适合传递可选参数或过滤条件。|
## 代码实现
```java
@Override  
public ResponseResult getArticleDetail(Long id) {  
    //根据id查询文章  
    Article article = getById(id);  
  
    //根据分类id查询分类名  
    Category category = categoryService.getById(article.getCategoryId());  
  
    //使用Optional的ofNullable来防止空指针，并将categoryName设置到article中  
    Optional<Category> categoryOptional = Optional.ofNullable(category);  
    categoryOptional.ifPresent(category1 -> article.setCategoryName(category1.getName()));  
  
    //转换为vo  
    ArticleDetailVo articleDetailVo = BeanCopyUtils.copyBean(article, ArticleDetailVo.class);  
  
    //封装响应返回  
    return ResponseResult.okResult(articleDetailVo);  
}
```
# 友链功能
## 表分析
![[Pasted image 20231222231535.png]]
## 接口分析
	在友链页面要查询出所有的审核通过的友链，响应格式如下
```json
{
  "code": 200,
  "data": [
    {
      "address": "https://www.baidu.com",
      "description": "sda",
      "id": "1",
      "logo": "图片url1",
      "name": "sda"
    },
    {
      "address": "https://www.qq.com",
      "description": "dada",
      "id": "2",
      "logo": "图片url2",
      "name": "sda"
    }
  ],
  "msg": "操作成功"
}
```
## 代码实现
```java
@Override  
public ResponseResult getAllLink() {  
    //查询所有审核通过的友链  
    LambdaQueryWrapper<Link> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Link::getStatus, SystemCanstants.LINK_STATUS_NORMAL);  
    List<Link> links = list(queryWrapper);  
    //转换vo  
    List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(links, LinkVo.class);  
    return ResponseResult.okResult(linkVos);  
}
```
# 登录功能
## 表分析
![[Pasted image 20231223213733.png]]
需要实现登录功能，有些功能必须登录后才能使用，未登录状态是不能使用的。请求形式如下
- 请求体
```json
{
    "userName":"sg",
    "password":"1234"
}
```
- 响应格式
```json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk",
        "userInfo": {
            "avatar": "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F3bf9c263bc0f2ac5c3a7feb9e218d07475573ec8.gi",
            "email": "23412332@qq.com",
            "id": 1,
            "nickName": "sg333",
            "sex": "1"
        }
    },
    "msg": "操作成功"
}
```
## 思路分析
- 登录
	1. 自定义登录接口
		调用 ProviderManager 的方法进行认证，认证通过生成 jwt
		把用户信息存入redis
	2. 自定义 UserDetailService 
		在这个实现类中查询数据库
注意配置 passwordEncoder 为 BCryptPasswordEncorder
		
- 校验
	1. 定义 Jwt 认证过滤器
		获取 token
		解析 token 获取 userID 
		从 redis 中获取用户信息
		存入 SecurityContextHolder 
		
具体实现流程可查看 [[SpringSecurity study]] 
## 准备工作
- 相关依赖
```xml
<!--SpringSecurity启动器-->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>  
<!--redis依赖-->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis</artifactId>  
</dependency>  
<!--fastjson依赖-->  
<dependency>  
    <groupId>com.alibaba</groupId>  
    <artifactId>fastjson</artifactId>  
</dependency>  
<!--jwt依赖-->  
<dependency>  
    <groupId>io.jsonwebtoken</groupId>  
    <artifactId>jjwt</artifactId>  
</dependency>
```
- 配置类和工具类
[[FastJsonRedisSerializer]]
[[RedisConfig]]
[[JwtUtils]]
[[RedisCache]]
[[WebUtils]]
## 登录代码实现
### BlogUserController
```java
package com.xinzhou.controller;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.service.BlogLoginService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
public class BlogLoginController {  
    @Autowired  
    private BlogLoginService blogLoginService;  
  
    @PostMapping("/login")  
    public ResponseResult login(@RequestBody User user){  
        return blogLoginService.login(user);  
    }  
}
```
### BlogLoginService 
```java
package com.xinzhou.service;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.User;  
  
public interface BlogLoginService {  
    ResponseResult login(User user);  
}
```
### SecurityConfig
```java
package com.xinzhou.config;  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
				//除上面外的所有请求全部不需要认证即可访问  
				.anyRequest().permitAll(); 
        //配置认证过滤器  
//        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
//        //配置异常处理器  
//        http.exceptionHandling()  
//                //配置认证失败处理器  
//                .authenticationEntryPoint(authenticationEntryPoint)  
//                //配置授权失败处理器  
//                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
### BlogLoginServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.BlogUserLoginVo;  
import com.xinzhou.domain.vo.UserInfoVo;  
import com.xinzhou.service.BlogLoginService;  
import com.xinzhou.utils.BeanCopyUtils;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.Authentication;  
import org.springframework.stereotype.Service;  
  
import java.util.Objects;  
  
/**  
 * 认证，判断用户登录是否成功  
 */  
@Service  
public class BlogLoginServiceImpl implements BlogLoginService {  
    @Autowired  
    private AuthenticationManager authenticationManager;  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    public ResponseResult login(User user) {  
        //封装登录的用户名和密码  
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());  
        //在下一行之前，封装的数据会先走UserDetailsServiceImpl实现类  
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);  
        //上面那一行会得到所有的认证用户信息authenticate。然后下一行需要判断用户认证是否通过，如果authenticate的值是null，就说明认证没有通过  
  
        //判断是否验证通过  
        if(Objects.isNull(authenticate))  
            throw new RuntimeException("用户名或密码错误");  
  
        //获取userId生成Token  
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();  
        String userId = loginUser.getUser().getId().toString();  
        String jwt = JwtUtil.createJWT(userId);  
        //把用户信息存入redis  
        redisCache.setCacheObject("bloglogin:"+userId,loginUser);  
        //把token和userInfo封装并返回  
        //把User转换成UserInfoVo  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);  
        BlogUserLoginVo vo = new BlogUserLoginVo(jwt,userInfoVo);  
        return ResponseResult.okResult(vo);  
    }  
}
```
### UserDetailServiceImpl
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.mapper.UserMapper;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.core.userdetails.UsernameNotFoundException;  
import org.springframework.stereotype.Service;  
  
import java.util.Objects;  
  
/**  
 * 当BlogLoginServiceImpl类封装好登录的用户名和密码之后，就会传到当前这个实现类  
 */  
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private UserMapper userMapper;  
    @Override  
    //在这里之前，我们已经拿到了登录的用户名和密码。UserDetails是SpringSecurity官方提供的接口  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
  
        //根据用户名查询用户信息  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getUserName,username);  
        User user = userMapper.selectOne(queryWrapper);  
        //判断是否查询到用户 如果没查询到则抛出异常  
        if (Objects.isNull(user))  
            throw new RuntimeException("用户不存在");//后期会对异常进行统一处理  
        //TODO 查询权限信息封装  
        //返回用户信息  
        return new LoginUser(user);  
    }  
}
```
### LoginUser 
```java
package com.xinzhou.domain.pojo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
import org.springframework.security.core.GrantedAuthority;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Collection;  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
//UserDetails是SpringSecurity官方提供的接口  
public class LoginUser implements UserDetails {  
    private User user;  
  
    /**  
     * 用于返回权限信息。现在我们正在实现'认证'，'权限'后面才用得到。所以返回null即可  
     * 当要查询用户信息的时候，我们不能单纯返回null，要重写这个方法，作用是返回权限信息  
     * @return  
     */  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return null;  
    }  
  
    /**  
     * 用于获取用户密码。由于使用的实体类是User，所以获取的是数据库的用户密码  
     * @return  
     */  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    /**  
     * 用于获取用户名。由于使用的实体类是User，所以获取的是数据库的用户名  
     * @return  
     */  
    @Override  
    public String getUsername() {  
        return user.getUserName();  
    }  
  
    /**  
     * 判断登录状态是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isAccountNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断账号是否被锁定。把这个改成true，表示未锁定  
     * @return  
     */  
    @Override  
    public boolean isAccountNonLocked() {  
        return true;  
    }  
  
    /**  
     * 判断登录凭证是否过期。把这个改成true，表示永不过期  
     * @return  
     */  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return true;  
    }  
  
    /**  
     * 判断用户是否可用。把这个改成true，表示可用状态  
     * @return  
     */  
    @Override  
    public boolean isEnabled() {  
        return true;  
    }  
}
```
### BlogUserLoginVo 
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class BlogUserLoginVo {  
    private String token;  
    private UserInfoVo userInfo;  
}
```
### UserInfoVo 
```java
package com.xinzhou.domain.vo;  
  
import com.baomidou.mybatisplus.annotation.IdType;  
import com.baomidou.mybatisplus.annotation.TableId;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class UserInfoVo {  
    /**  
     * 主键  
     */  
    @TableId(type = IdType.AUTO)  
    private Long id;  
  
    /**  
     * 用户名  
     */  
    private String userName;  
  
    /**  
     * 昵称  
     */  
    private String nickName;  
  
    /**  
     * 邮箱  
     */  
    private String email;  
  
    /**  
     * 用户性别（0男，1女，2未知）  
     */  
    private String sex;  
  
    /**  
     * 头像  
     */  
    private String avatar;  
  
}
```
### 遇到的问题
`java.lang.ClassNotFoundException:javax.xml.bind.DatatypeConverter`

解决方案：
```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
```
因为 javax.xml.bind 在 jdk8中有，但是在更高版本就没有了，所以我们加上就行了。
# 认证过滤器代码实现
校验思路

1. 定义 Jwt 认证过滤器  
    获取 token  
    解析 token 获取 userID  
    从 redis 中获取用户信息  
    存入 SecurityContextHolder 
### JwtAuthenticationTokenFilter 
```java
package com.xinzhou.filter;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.LoginUser;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.JwtUtil;  
import com.xinzhou.utils.RedisCache;  
import com.xinzhou.utils.WebUtils;  
import io.jsonwebtoken.Claims;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.stereotype.Component;  
import org.springframework.util.StringUtils;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.util.Objects;  
  
@Component  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
    @Autowired  
    private RedisCache redisCache;  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
  
        //获取 token        
        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)){  
            //该接口不需要token，直接放行  
            filterChain.doFilter(request,response);  
            return;  
        }  
        //解析 token 获取 userID        Claims claims = null;  
        try {  
            claims = JwtUtil.parseJWT(token);  
        } catch (Exception e) {  
            e.printStackTrace();  
            //token超时或token非法  
            //响应给前端需要重新登录，通过WebUtils工具类设置响应码  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        String userId = claims.getSubject();  
        //从 redis 中获取用户信息  
        LoginUser loginUser = redisCache.getCacheObject("bloglogin:" + userId);  
        //如果获取不到用户信息  
        if(Objects.isNull(loginUser)){  
            //说明登录过期，重新登录  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        //存入 SecurityContextHolder        
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
  
        filterChain.doFilter(request,response);  
    }  
}
```
### 配置认证过滤器 
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
//        //配置异常处理器  
//        http.exceptionHandling()  
//                //配置认证失败处理器  
//                .authenticationEntryPoint(authenticationEntryPoint)  
//                //配置授权失败处理器  
//                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 认证授权的异常处理
	目前我们的项目在认证出错或者权限不足的时候响应回来的 Json，默认是使用 Security 官方提供的响应的格式，但是这种响应的格式肯定是不符合我们项目的接口规范的。所以需要自定义异常处理
	
	我们需要去实现AuthenticationEntryPoint(官方提供的认证失败处理器)类、AccessDeniedHandler(官方提供的授权失败处理器)类，然后配置给Security
### 认证失败处理器实现类 AuthenticationEntryPointImpl
```java
package com.xinzhou.handler.security;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.security.authentication.BadCredentialsException;  
import org.springframework.security.authentication.InsufficientAuthenticationException;  
import org.springframework.security.core.AuthenticationException;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.stereotype.Component;  
  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
  
@Component  
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {  
    @Override  
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {  
        //打印异常信息  
        e.printStackTrace();  
  
        //判断是登录才出现异常(返回'用户名或密码错误')，还是没有登录就访问特定接口才出现的异常(返回'需要登录后访问')，还是其它情况(返回'出现错误')  
        ResponseResult result = null;  
        if(e instanceof BadCredentialsException){  
            //第一个参数返回的是响应码，AppHttpCodeEnum是我们写的实体类。第二个参数是返回具体的信息  
            result = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR.getCode(),e.getMessage());  
        } else if(e instanceof InsufficientAuthenticationException){  
            result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
        } else {  
            result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),"认证或授权失败");  
        }  
  
        //将响应结果转化为Json响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```
### 授权失败处理器实现类 AccessDeniedHandlerImpl
```java
package com.xinzhou.handler.security;  
  
import com.alibaba.fastjson.JSON;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.utils.WebUtils;  
import org.springframework.security.access.AccessDeniedException;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.stereotype.Component;  
  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
@Component  
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {  
    @Override  
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {  
        //打印异常信息  
        e.printStackTrace();  
  
        ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH);  
        //将响应结果转化为Json响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```
### 配置认证授权异常处理器
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 统一异常处理
实际我们在开发过程中可能需要做很多的判断校验，如果出现了非法情况我们是期望响应对应的提示的。但是如果我们每次都自己手动去处理就会非常麻烦。我们可以选择直接抛出异常的方式，然后对异常进行统一处理。把异常中的信息封装成 ResponseResult 响应给前端
- 在 framework 模块下新建 exception. SystemException 类
```java
package com.xinzhou.exception;  
  
import com.xinzhou.enums.AppHttpCodeEnum;  
  
/**  
 * @author xinxinzhou  
 * @date 2023/7/23 0023 21:54  
 *///统一异常处理  
public class SystemException extends RuntimeException{  
  
    private int code;  
  
    private String msg;  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    //定义一个构造方法，接收的参数是枚举类型，AppHttpCodeEnum是我们在framework工程定义的枚举类  
    public SystemException(AppHttpCodeEnum httpCodeEnum) {  
        super(httpCodeEnum.getMsg());  
        //把某个枚举类里面的code和msg赋值给异常对象  
        this.code = httpCodeEnum.getCode();  
        this.msg = httpCodeEnum.getMsg();  
    }  
}
```
- 在 framework 工模块下新建 handler. exception. GlobalExceptionHandler 类
```java
package com.xinzhou.handler.exception;  
  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.enums.AppHttpCodeEnum;  
import com.xinzhou.exception.SystemException;  
import lombok.extern.slf4j.Slf4j;  
  
import org.springframework.web.bind.annotation.ExceptionHandler;  
import org.springframework.web.bind.annotation.RestControllerAdvice;  
  
/**  
 * @author 14674  
 * @date 2023/7/23 0023 22:03  
 *///@ControllerAdvice //对controller层的增强  
//@ResponseBody  
  
//或者用下面一个注解代替上面的两个注解  
@RestControllerAdvice  
  
//使用Lombok提供的Slf4j注解，实现日志功能  
@Slf4j  
  
//全局异常处理。最终都会在这个类进行处理异常  
public class GlobalExceptionHandler {  
  
    //SystemException是我们写的类。用户登录的异常交给这里处理  
    @ExceptionHandler(SystemException.class)  
    public ResponseResult systemExceptionHandler(SystemException e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult是我们写的类  
        return ResponseResult.errorResult(e.getCode(),e.getMsg());  
    }  
  
    //其它异常交给这里处理  
    @ExceptionHandler(Exception.class)  
    public ResponseResult exceptionHandler(Exception e){  
  
        //打印异常信息，方便我们追溯问题的原因。{}是占位符，具体值由e决定  
        log.error("出现了异常! {}",e);  
  
        //从异常对象中获取提示信息封装，然后返回。ResponseResult、AppHttpCodeEnum是我们写的类  
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());//枚举值是500  
    }  
}
```
- 修改 BlogLoginController
```java
@RestController  
public class BlogLoginController {  
    @Autowired  
    private BlogLoginService blogLoginService;  
  
    @PostMapping("/login")  
    public ResponseResult login(@RequestBody User user){  
        //如果用户在进行登录时，没有传入'用户名',提示'必须要传用户名'。AppHttpCodeEnum是我们写的枚举类。SystemException是我们写的统一异常处理的类  
        if(!StringUtils.hasText(user.getUserName()))  
            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);  
        return blogLoginService.login(user);  
    }  
}
```
# 退出登录
## 接口分析
|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/logout|需要 token 请求头|
## 代码实现
- 在 BlogLoginServiceImpl 中实现退出登录
```java
/**  
 * 退出登录  
 * @return  
 */  
@Override  
public ResponseResult logout() {  
    //获取token，解析获取userId  
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
    LoginUser loginUser = (LoginUser) authentication.getPrincipal();  
    Long userId = loginUser.getUser().getId();  
    //删除redis中用户信息  
    redisCache.deleteObject("bloglogin:" + userId);  
    return ResponseResult.okResult();  
}
```
- 在 SecurityConfig 类修改为如下，增加了需要有登录状态才能执行退出登录，否则就报'401 需要登录后操作'
```java
package com.xinzhou.config;  
  
import com.xinzhou.filter.JwtAuthenticationTokenFilter;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.authentication.AuthenticationManager;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
    @Override  
    @Bean    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Autowired  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  
    //注入官方的认证\授权失败的处理器。注意不用写private，并且不是注入我们自定义的认证\授权失败处理器。理由:符合开闭原则  
    //虽然我们注入的不是自己写的认证\授权失败处理器，但是最终用的实际上就是我们写的，Security会自己去找我们写的  
    @Autowired  
    AuthenticationEntryPoint authenticationEntryPoint;  
    @Autowired  
    AccessDeniedHandler accessDeniedHandler;  
    /**  
     * 更改加密方式  
     * @return  
     */  
    @Bean  
    public PasswordEncoder passwordEncoder(){  
        return new BCryptPasswordEncoder();  
    }  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                //对于登录接口，允许匿名访问  
                .antMatchers("/login").anonymous()  
                //退出登录接口，需要登录才能调用  
                .antMatchers("/logout").authenticated()  
                //除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
        //配置认证过滤器  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //配置异常处理器  
        http.exceptionHandling()  
                //配置认证失败处理器  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //配置授权失败处理器  
                .accessDeniedHandler(accessDeniedHandler);  
        http.logout().disable();  
        //配置跨域  
        http.cors();  
    }  
}
```
# 评论列表
## 评论表分析
![[Pasted image 20231224172656.png]]
## 接口分析
|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/comment/commentList|不需要 token 请求头(未登录也能看到评论信息)|
- Query 格式请求参数如下:
```
articleId:文章id
pageNum:页码
pageSize:每页条数
```
- 响应格式如下，包含了根评论+子评论:
```json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "评论内容(子评论)",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:06:21",
                        "id": "20",
                        "rootId": "1",
                        "toCommentId": "1",
                        "toCommentUserId": "1",
                        "toCommentUserName": "这条评论(子评论)回复的是哪个人",
                        "username": "发这条评论(子评论)的人"
                    }
                ],
                "content": "评论内容(根评论)",
                "createBy": "1",
                "createTime": "2022-01-29 07:59:22",
                "id": "1",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "发这条评论(根评论)的人"
            }
        ],
        "total": "15"
    },
    "msg": "操作成功"
}
```
## 代码实现-不考虑子评论
### 新建 CommentVo 类, 用来封装返回的评论
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class CommentVo {  
    private Long id;  
  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    //所回复评论的用户名  
    private String toCommentUserName;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */    private Long createBy;  
  
    /**  
     *     */    private Date createTime;  
  
    //评论人  
    private String username;  
  
}
```
### CommentServiceImpl 实现类
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.CommentVo;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.service.CommentService;  
import com.xinzhou.mapper.CommentMapper;  
import com.xinzhou.service.UserService;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.function.Function;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【comment(评论表)】的数据库操作Service实现  
* @createDate 2023-12-25 00:18:11  
*/  
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
    @Autowired  
    private UserService userService;  
  
    @Override  
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
  
        //查询对应文章的根评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        //对articleId进行判断  
        queryWrapper.eq(Comment::getArticleId,articleId);  
        //根评论的rootId为-1,SystemCanstants是我们写的解决字面值的类,COMMENT_ROOT标识评论为根评论  
        queryWrapper.eq(Comment::getRootId, SystemCanstants.COMMENT_ROOT);  
        //分页查询  
        Page<Comment> page = new Page<>(pageNum,pageSize);  
        page(page,queryWrapper);  
  
        //封装成CommentVo,  
        List<CommentVo> commentVos = toCommentVoList(page.getRecords());  
  
  
        //封装成响应实体并返回  
        return ResponseResult.okResult(new PageVo(commentVos,page.getTotal()));  
    }  
  
    /**  
     * 将封装CommentVo定义为方法调用  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
        //遍历vo集合  
        commentVos.stream()  
                .map(commentVo -> {  
                    //通过creatBy查询评论人的用户名  
                    String nickName = userService.getById(commentVo.getCreateBy()).getNickName();  
                    commentVo.setUsername(nickName);  
  
                    //通过toCommentUserId查询所评论的用户名昵称并赋值  
                    //如果toCommentUserId不为-1才进行查询，不为-1标识该评论不为根评论，有所回复的用户名  
                    if(!Objects.equals(commentVo.getToCommentUserId(), SystemCanstants.COMMENT_ROOT)){  
                        String toCommentUserName = userService.getById(commentVo.getToCommentUserId()).getNickName();  
                        commentVo.setToCommentUserName(toCommentUserName);  
                    }  
                    return commentVo;  
                }).collect(Collectors.toList());  
        return commentVos;  
    }  
}
```
## 代码实现-考虑子评论 
### 在 CommentVo 类中增加了子评论字段
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.Date;  
import java.util.List;  
  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class CommentVo {  
    private Long id;  
  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    //所回复评论的用户名  
    private String toCommentUserName;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */    private Long createBy;  
  
    /**  
     *     */    private Date createTime;  
  
    //评论人  
    private String username;  
  
    //子评论  
    private List<CommentVo> children;  
  
}
```
### 把 CommentServiceImpl 修改为如下，增加了查询子评论、子评论按照时间排序、根评论按照时间排序
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.domain.pojo.User;  
import com.xinzhou.domain.vo.CommentVo;  
import com.xinzhou.domain.vo.PageVo;  
import com.xinzhou.service.CommentService;  
import com.xinzhou.mapper.CommentMapper;  
import com.xinzhou.service.UserService;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Objects;  
import java.util.function.Function;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【comment(评论表)】的数据库操作Service实现  
* @createDate 2023-12-25 00:18:11  
*/  
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
    @Autowired  
    private UserService userService;  
  
    @Override  
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
  
        //查询对应文章的根评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        //对articleId进行判断  
        queryWrapper.eq(Comment::getArticleId,articleId);  
        //根评论的rootId为-1,SystemCanstants是我们写的解决字面值的类,COMMENT_ROOT标识评论为根评论  
        queryWrapper.eq(Comment::getRootId, SystemCanstants.COMMENT_ROOT);  
        //分页查询  
        Page<Comment> page = new Page<>(pageNum,pageSize);  
        page(page,queryWrapper);  
  
        //封装成CommentVo,  
        List<CommentVo> commentVos = toCommentVoList(page.getRecords());  
  
        //查询所有根评论对应的子评论集合，并赋值给对应的属性。  
        commentVos.stream()  
                .map( commentVo -> {  
                    //查询对应的子评论  
                    List<CommentVo> children = getChildren(commentVo.getId());  
                    //赋值  
                    commentVo.setChildren(children);  
                    return commentVo;  
                }).collect(Collectors.toList());  
  
  
        //封装成响应实体并返回  
        return ResponseResult.okResult(new PageVo(commentVos,page.getTotal()));  
    }  
  
    /**  
     * 根据根评论的id查询对应子评论的集合  
     * @param id 根评论的id  
     * @return  
     */  
    private List<CommentVo> getChildren(Long id){  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(Comment::getRootId,id)  
                //对子评论按照时间进行排序  
                .orderByAsc(Comment::getCreateTime);  
        List<Comment> comments = list(queryWrapper);  
        //调用toCommentVoList,封装CommentVo  
        return toCommentVoList(comments);  
    }  
  
    /**  
     * 将封装CommentVo定义为方法调用  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
        //遍历vo集合  
        commentVos.stream()  
                .map(commentVo -> {  
                    //通过creatBy查询评论人的用户名  
                    String nickName = userService.getById(commentVo.getCreateBy()).getNickName();  
                    commentVo.setUsername(nickName);  
  
                    //通过toCommentUserId查询所评论的用户名昵称并赋值  
                    //如果toCommentUserId不为-1才进行查询，不为-1标识该评论不为根评论，有所回复的用户名  
                    if(!Objects.equals(commentVo.getToCommentUserId(), SystemCanstants.COMMENT_ROOT)){  
                        String toCommentUserName = userService.getById(commentVo.getToCommentUserId()).getNickName();  
                        commentVo.setToCommentUserName(toCommentUserName);  
                    }  
                    return commentVo;  
                }).collect(Collectors.toList());  
        return commentVos;  
    }  
}
```
# 发送评论
## 接口分析
用户登录后可以对文章发表评论，也可以对已有的评论进行回复

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|POST|/comment|需要 token 头|
【请求体】
回复了文章。0表示文章评论，如果是友链评论，type 应该为1：
```json
{"articleId":1,"type":0,"rootId":-1,"toCommentId":-1,"toCommentUserId":-1,"content":"评论了文章"}
```
【响应格式】
```json
{
	"code":200,
	"msg":"操作成功"
}
```
## 代码实现
### SecurityUtils 类
```java
package com.xinzhou.utils;  
  
import com.xinzhou.domain.pojo.LoginUser;  
import org.springframework.security.core.Authentication;  
import org.springframework.security.core.context.SecurityContextHolder;  
  
/**  
 * @author 35238  
 * @date 2023/7/26 0026 20:43  
 */  
//在'发送评论'功能那里会用到的工具类  
public class SecurityUtils {  
  
    /**  
     * 获取用户的userid  
     **/    public static LoginUser getLoginUser() {  
        return (LoginUser) getAuthentication().getPrincipal();  
    }  
  
    /**  
     * 获取Authentication  
     */    public static Authentication getAuthentication() {  
        return SecurityContextHolder.getContext().getAuthentication();  
    }  
  
    /**  
     * 指定userid为1的用户就是网站管理员  
     * @return  
     */  
    public static Boolean isAdmin(){  
        Long id = getLoginUser().getUser().getId();  
        return id != null && 1L == id;  
    }  
  
    public static Long getUserId() {  
        return getLoginUser().getUser().getId();  
    }  
}
```
### 配置 MP 自动填充公共字段
```java
package com.xinzhou.handler.mybatisplus;  
  
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;  
import com.xinzhou.utils.SecurityUtils;  
import org.apache.ibatis.reflection.MetaObject;  
import org.springframework.stereotype.Component;  
  
import java.util.Date;  
  
/**  
 * @author 35238  
 * @date 2023/7/26 0026 20:52  
 */@Component  
//这个类是用来配置mybatis的字段自动填充。用于'发送评论'功能，由于我们在评论表无法对下面这四个字段进行插入数据  
//请求体提供下面四个参数，所以后端在往数据库插入数据时，下面四个字段是空值)，所有就需要这个类来帮助我们往下面这四个字段自动的插入值，  
//只要我们更新了评论表的字段，那么无法插入值的字段就自动有值了  
public class MyMetaObjectHandler implements MetaObjectHandler {  
  
    @Override  
    //只要对数据库执行了插入语句，那么就会执行到这个方法  
    public void insertFill(MetaObject metaObject) {  
        Long userId = null;  
        try {  
            //获取用户id  
            userId = SecurityUtils.getUserId();  
        } catch (Exception e) {  
            e.printStackTrace();  
            userId = -1L;//如果异常了，就说明该用户还没注册，我们就把该用户的userid字段赋值d为-1  
        }  
        //自动把下面四个字段新增了值。  
        this.setFieldValByName("createTime", new Date(), metaObject);  
        this.setFieldValByName("createBy",userId , metaObject);  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName("updateBy", userId, metaObject);  
    }  
  
    @Override  
    public void updateFill(MetaObject metaObject) {  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName(" ", SecurityUtils.getUserId(), metaObject);  
    }  
}
```
### 修改 Comment 类，增加了具体的自动填充规则
```java
package com.xinzhou.domain.pojo;  
  
import com.baomidou.mybatisplus.annotation.*;  
  
import java.io.Serializable;  
import java.util.Date;  
import lombok.Data;  
  
/**  
 * 评论表  
 * @TableName comment  
 */@TableName(value ="comment")  
@Data  
public class Comment implements Serializable {  
    /**  
     *     */  
    @TableId(type = IdType.AUTO)  
    private Long id;  
  
    /**  
     * 评论类型（0代表文章评论，1代表友链评论）  
     */  
    private String type;  
  
    /**  
     * 文章id  
     */    private Long articleId;  
  
    /**  
     * 根评论id  
     */    private Long rootId;  
  
    /**  
     * 评论内容  
     */  
    private String content;  
  
    /**  
     * 所回复的目标评论的userid  
     */    private Long toCommentUserId;  
  
    /**  
     * 回复目标评论id  
     */    private Long toCommentId;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT)  
    private Long createBy;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT)  
    private Date createTime;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT_UPDATE)  
    private Long updateBy;  
  
    /**  
     *     */  
    @TableField(fill = FieldFill.INSERT_UPDATE)  
    private Date updateTime;  
  
    /**  
     * 删除标志（0代表未删除，1代表已删除）  
     */  
    private Integer delFlag;  
  
    @TableField(exist = false)  
    private static final long serialVersionUID = 1L;  
}
```
### 在 CommentServiceImpl 类，增加了发送评论的代码实现
```java
/**  
 * 添加评论  
 * @param comment  
 * @return  
 */  
@Override  
public ResponseResult addComment(Comment comment) {  
    //注意前端在调用这个发送评论接口时，在请求体是没有向我们传入createTime、createId、updateTime、updateID字段，所以  
    //我们这里往后端插入数据时，就会导致上面那行的四个字段没有值  
    //为了解决这个问题，我们在framework工程新增了MyMetaObjectHandler类、修改了Comment类  
    //限制用户在发送评论时，评论内容不能为空。如果为空就抛出异常  
    if(!StringUtils.hasText(comment.getContent()))  
        throw new SystemException(AppHttpCodeEnum.CONTENT_NOT_NULL);  
    //调用mybatisplus提供的save方法往数据库插入数据(用户发送的评论的各个字段)了  
    save(comment);  
    return ResponseResult.okResult();  
}
```
### 修改 CommentController 类，增加了发送评论的请求路径
```java
/**  
 * 发送评论  
 * @param comment  
 * @return  
 */  
package com.xinzhou.controller;  
  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Comment;  
import com.xinzhou.service.CommentService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.web.bind.annotation.*;  
  
@RestController  
@RequestMapping("/comment")  
public class CommentController {  
    @Autowired  
    private CommentService commentService;  
    @GetMapping("/commentList")  
    public ResponseResult commentList(Long articleId,Integer pageNum,Integer pageSize){  
        return commentService.commentList(articleId,pageNum,pageSize);  
    }  
  
    /**  
     * 发送评论  
     * @param comment  
     * @return  
     */  
    @PostMapping  
    public ResponseResult addComment(@RequestBody Comment comment){  
        return commentService.addComment(comment);  
    }  
}
```
# 友链评论列表
## 接口分析
用户登录后可以对友链发表评论，也可以对已有的评论进行回复

|   |   |   |
|---|---|---|
|请求方式|请求地址|请求头|
|GET|/comment/linkCommentList|不需要 token 请求头|
- Query 格式请求参数：
```text
pageNum: 页码
pageSize: 每页条数
```
- 响应格式:
```json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "回复友链评论3",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:08:50",
                        "id": "23",
                        "rootId": "22",
                        "toCommentId": "22",
                        "toCommentUserId": "1",
                        "toCommentUserName": "sg333",
                        "username": "sg333"
                    }
                ],
                "content": "友链评论2",
                "createBy": "1",
                "createTime": "2022-01-30 10:08:28",
                "id": "22",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "sg333"
            }
        ],
        "total": "1"
    },
    "msg": "操作成功"
}
```
