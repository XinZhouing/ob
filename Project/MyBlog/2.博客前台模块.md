# 文章列表
## 表分析
![[Pasted image 20231221205536.png]]
## 热门文章接口分析
需要查询浏览量最高的前10篇文章的信息。要求展示文章标题和浏览量。把能让用户自己点击跳转到具体的文章详情进行浏览
注意：不能把草稿展示出来，不能把删除了的文章查询出来。要按照浏览量进行降序排序
## 统一响应格式
在公共模块下新建枚举类和响应实体类
```java
package com.xinzhou.enums;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:52  
 */public enum AppHttpCodeEnum {  
    // 成功  
    SUCCESS(200,"操作成功"),  
    // 登录  
    NEED_LOGIN(401,"需要登录后操作"),  
    NO_OPERATOR_AUTH(403,"无权限操作"),  
    SYSTEM_ERROR(500,"出现错误"),  
    USERNAME_EXIST(501,"用户名已存在"),  
    PHONENUMBER_EXIST(502,"手机号已存在"),  
    EMAIL_EXIST(503, "邮箱已存在"),  
    REQUIRE_USERNAME(504, "必需填写用户名"),  
    LOGIN_ERROR(505,"用户名或密码错误");  
    int code;  
    String msg;  
  
    AppHttpCodeEnum(int code, String errorMessage){  
        this.code = code;  
        this.msg = errorMessage;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
}
```
```java
package com.xinzhou.domain;  
  
import com.fasterxml.jackson.annotation.JsonInclude;  
import com.xinzhou.enums.AppHttpCodeEnum;  
  
import java.io.Serializable;  
  
/**  
 * @author xinzhou  
 * @date 2023/12/21 0019 12:49  
 *///统一响应格式。实体类，或者这个类严格来说叫响应体  
@JsonInclude(JsonInclude.Include.NON_NULL)  
public class ResponseResult<T> implements Serializable {  
    private Integer code;  
    private String msg;  
    private T data;  
  
    public ResponseResult() {  
        this.code = AppHttpCodeEnum.SUCCESS.getCode();  
        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();  
    }  
  
    public ResponseResult(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg, T data) {  
        this.code = code;  
        this.msg = msg;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
    }  
  
    public static ResponseResult errorResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.error(code, msg);  
    }  
    public static ResponseResult okResult() {  
        ResponseResult result = new ResponseResult();  
        return result;  
    }  
    public static ResponseResult okResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.ok(code, null, msg);  
    }  
  
    public static ResponseResult okResult(Object data) {  
        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());  
        if(data!=null) {  
            result.setData(data);  
        }  
        return result;  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums){  
        return setAppHttpCodeEnum(enums,enums.getMsg());  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){  
        return setAppHttpCodeEnum(enums,msg);  
    }  
  
    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){  
        return okResult(enums.getCode(),enums.getMsg());  
    }  
  
    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){  
        return okResult(enums.getCode(),msg);  
    }  
  
    public ResponseResult<?> error(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data, String msg) {  
        this.code = code;  
        this.data = data;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(T data) {  
        this.data = data;  
        return this;  
    }  
  
    public Integer getCode() {  
        return code;  
    }  
  
    public void setCode(Integer code) {  
        this.code = code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
  
    public T getData() {  
        return data;  
    }  
  
    public void setData(T data) {  
        this.data = data;  
    }  
  
}
```
## 代码实现
- 在 ArticleServiceImpl 中实现 hotArticleList 方法
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    return ResponseResult.okResult(articles);  
}
```
## 测试接口
访问： http://localhost:7777/article/hotArticleList 
![[Pasted image 20231221213915.png]]
## 后端解决跨域
```java
package com.xinzhou.config;  
  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.servlet.config.annotation.CorsRegistry;  
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  
  
@Configuration  
public class WebConfig implements WebMvcConfigurer {  
  
    @Override  
    public void addCorsMappings(CorsRegistry registry) {  
        // 设置允许跨域的路径  
        registry.addMapping("/**")  
                // 设置允许跨域请求的域名  
                .allowedOriginPatterns("*")  
                // 是否允许cookie  
                .allowCredentials(true)  
                // 设置允许的请求方式  
                .allowedMethods("GET", "POST", "DELETE", "PUT")  
                // 设置允许的header属性  
                .allowedHeaders("*")  
                // 跨域允许时间  
                .maxAge(3600);  
    }  
  
}
```
## 前端项目的启动
	npm install
	npm run dev
- 前后端联调
![[Pasted image 20231221220012.png]]
## 优化
- VO 优化
```java
@Override  
public ResponseResult hotArticleList() {  
    //查询热门文章 封装成ResponseResult返回  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    //必须是正式文章  
    queryWrapper.eq(Article::getStatus,0);  
    //按照浏览量排序  
    queryWrapper.orderByDesc(Article::getViewCount);  
    //最多只查询10条文章  
    Page<Article> page = new Page(1,10);  
    page(page,queryWrapper);  
    List<Article> articles = page.getRecords();  
  
    //bean拷贝  
    List<HotArticleVo> articleVos = new ArrayList<>();  
    for(Article article : articles){  
        HotArticleVo vo = new HotArticleVo();  
        BeanUtils.copyProperties(article,vo);  
        articleVos.add(vo);  
    }  
  
    return ResponseResult.okResult(articleVos);  
}
```
- 字面值处理
	实际项目中都不允许直接在代码中使用字面值 (代码中的固定值)。都需要定义成常量来使用。这种方式有利于提高代码的可维护性。
```java
package com.xinzhou.constants;  
  
public class SystemCanstants {  
  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
      
    /**  
     *  文章是正常分布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
      
}
```
优化后：
```java
//必须是正式文章  
queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);
```
- Bean 拷贝的封装
```java
package com.xinzhou.utils;  
  
import org.springframework.beans.BeanUtils;  
import java.util.List;  
import java.util.stream.Collectors;  
  
public class BeanCopyUtils {  
    private BeanCopyUtils(){  
    }  
  
    public static <V> V copyBean(Object source,Class<V> clazz) {  
        //创建目标对象  
        V result = null;  
        try {  
            result = clazz.newInstance();  
            //实现属性拷贝  
            BeanUtils.copyProperties(source, result);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        //返回结果  
        return result;  
    }  
  
    public static <O,V> List<V> copyBeanList(List<O> list,Class<V> clazz){  
        return list.stream()  
                .map(o -> copyBean(o, clazz))  
                .collect(Collectors.toList());  
    }  
}
```
优化后：
```java
//bean拷贝  
List<HotArticleVo> articleVos = BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);
```
- 测试
![[Pasted image 20231221222806.png]]
# 分类列表
## 表分析
![[Pasted image 20231221223044.png]]
## 需求分析
	页面上需要展示分类列表，用户可以点击具体的分类查看该分类下的文章列表。要求只展示有发布正式文章的分类 。要求必须是正常(非禁用)状态的分类
## 代码实现
```java
package com.xinzhou.service.impl;  
  
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;  
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;  
import com.xinzhou.constants.SystemCanstants;  
import com.xinzhou.domain.ResponseResult;  
import com.xinzhou.domain.pojo.Article;  
import com.xinzhou.domain.pojo.Category;  
import com.xinzhou.domain.vo.CategoryVo;  
import com.xinzhou.service.ArticleService;  
import com.xinzhou.service.CategoryService;  
import com.xinzhou.mapper.CategoryMapper;  
import com.xinzhou.utils.BeanCopyUtils;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.util.List;  
import java.util.Set;  
import java.util.function.Function;  
import java.util.function.Predicate;  
import java.util.stream.Collectors;  
  
/**  
* @author 14674  
* @description 针对表【category(分类表)】的数据库操作Service实现  
* @createDate 2023-12-21 22:39:08  
*/  
@Service  
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService{  
  
    @Autowired  
    private ArticleService articleService;  
    @Override  
    public ResponseResult getCategoryList() {  
        //查询状态为已发布的文章表  
        LambdaQueryWrapper<Article> articleWrapper = new LambdaQueryWrapper<>();  
        articleWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
        List<Article> articleList = articleService.list(articleWrapper);  
        //获取文章的categoryId并去重  
        Set<Long> categoryIds = articleList.stream()  
                .map(Article::getCategoryId)  
                .collect(Collectors.toSet());  
        //查询分类状态为正常状态的分类表  
        List<Category> categories = listByIds(categoryIds);  
  
        categories = categories.stream()  
                .filter(category -> SystemCanstants.STATUS_NORMAL.equals(category.getStatus()))  
                .collect(Collectors.toList());  
        //封装vo  
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(categories, CategoryVo.class);  
        return ResponseResult.okResult(categoryVos);  
    }  
}
```
# 分页查询文章列表
## 接口分析
	首页需要查询所有的文章列表。分类页面需要查询对应分类下的文章列表。只能查询正式发布的文章，置顶的文章要显示在最前面
## 代码实现
	在公共模块的config 目录新建 MybatisPlusConfig 类，作用是配置 MyBatisPlus 的分页插件，不然分页没有效果
```java
package com.xinzhou.config;  
  
import com.baomidou.mybatisplus.annotation.DbType;  
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
@Configuration  
@MapperScan("com.xinzhou.mapper")  
public class MyBatisPlusConfig {  
  
    /**  
     * 配置分页插件  
     * @return  
     */  
    @Bean  
    public MybatisPlusInterceptor mybatisPlusInterceptor(){  
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();  
        //如果配置多个插件,切记分页最后添加  
        //如果有多数据源可以不配具体类型 否则都建议配上具体的DbType  
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));  
        return interceptor;  
    }  
}
```
	新建 PageVo 实体类，用于封装返回分页的数据
```java
package com.xinzhou.domain.vo;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import java.util.List;  
  
/**  
 * 封装返回分页的数据  
 */  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class PageVo {  
  
    private List rows;  
  
    private Long total;  
}
```
	解决问题：categoryName字段没有返回值，使用stream流，从article表中获取categoryId用于查询categoryName设置到Article对象中（在Article实体类中加入categoryName字段，并使用@TableFiled注释标识为数据库中不存在）
```java
@Override  
public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {  
    //条件：有categoryId查询时要传入相同的，状态是正式发布的，对isTop进行降序排序  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Objects.nonNull(categoryId)&&categoryId>0,Article::getCategoryId,categoryId);  
    queryWrapper.eq(Article::getStatus,SystemCanstants.ARTICLE_STATUS_NORMAL);  
    queryWrapper.orderByDesc(Article::getIsTop);  
  
    //分页查询  
    Page<Article> page = new Page<>(pageNum,pageSize);  
    page(page,queryWrapper);  
  
    //解决：查询categoryName为null问题，通过articleId去查询articleName进行设置  
    List<Article> articles = page.getRecords();  
    articles.stream()  
            .map(article -> {  
                //简化为一行：可以使用Lombok中@Accessors（chain=ture）注释Article实体类，可以将类中set方法的返回值设置为该类  
                article.setCategoryName(categoryService.getById(article.getCategoryId()).getName());  
                return article;  
            })  
            .collect(Collectors.toList());  
  
    //封装vo  
    List<ArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(page.getRecords(), ArticleListVo.class);  
  
    PageVo pageVo = new PageVo(articleListVos, page.getTotal());  
  
    return ResponseResult.okResult(pageVo);  
}
```
## FastJson 配置
	由于ArticleListVO类的createTime成员变量是Date类型，默认是由java的Jackson来处理，使用 ISO-8601 规范来处理日期时间格式。ISO-8601 是一种国际标准的日期时间表示法，例如："2023-07-21T06:53:24"。我们不希望时间被处理成这种格式。解决: 在WebConfig中配置使用FastJson 
```java
/**  
 * FastJson配置：时间格式问题  
 */  
@Bean//使用@Bean注入fastJsonHttpMessageConvert  
public HttpMessageConverter fastJsonHttpMessageConverters() {  
    //1.需要定义一个Convert转换消息的对象  
    FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();  
    FastJsonConfig fastJsonConfig = new FastJsonConfig();  
    fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);  
    fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");  
  
    SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);  
  
    fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);  
    fastConverter.setFastJsonConfig(fastJsonConfig);  
    HttpMessageConverter<?> converter = fastConverter;  
    return converter;  
}  
  
@Override  
//配置消息转换器  
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {  
    //增加我们的消息转换器  
    converters.add(fastJsonHttpMessageConverters());  
}
```
# 文章详情接口
## 接口分析
	要求在文章列表点击阅读全文时能够跳转到文章详情页面，可以让用户阅读文章正文。并且要在文章详情中展示其分类名。响应格式：
```json
{
  "code": 200,
  "data": {
    "categoryId": "1",
    "categoryName": "java",
    "content": "文章详情的具体文章内容",
    "createTime": "2022-01-23 23:20:11",
    "id": "1",
    "isComment": "0",
    "title": "SpringSecurity从入门到精通",
    "viewCount": "114"
  },
  "msg": "操作成功"
}
```
## 常用的 HTTP 请求形式
	以 GET /article/{id} 为例的路径参数形式，下面两种是比较常用的。不常用的有'请求体形式'、'请求头形式'

|   |   |   |
|---|---|---|
|请求形式|示例|描述|
|路径参数形式|/articles/{id}|参数作为路径的一部分，表示明确的资源标识符或必需的参数。|
|查询参数形式|/articles?id=1&num=1|参数通过 "?" 或 "&" 的方式附加在 URL 的末尾，适合传递可选参数或过滤条件。|
## 代码实现
```java
@Override  
public ResponseResult getArticleDetail(Long id) {  
    //根据id查询文章  
    Article article = getById(id);  
  
    //根据分类id查询分类名  
    Category category = categoryService.getById(article.getCategoryId());  
  
    //使用Optional的ofNullable来防止空指针，并将categoryName设置到article中  
    Optional<Category> categoryOptional = Optional.ofNullable(category);  
    categoryOptional.ifPresent(category1 -> article.setCategoryName(category1.getName()));  
  
    //转换为vo  
    ArticleDetailVo articleDetailVo = BeanCopyUtils.copyBean(article, ArticleDetailVo.class);  
  
    //封装响应返回  
    return ResponseResult.okResult(articleDetailVo);  
}
```
# 友链功能
## 表分析
![[Pasted image 20231222231535.png]]
## 接口分析
	在友链页面要查询出所有的审核通过的友链，响应格式如下
```json
{
  "code": 200,
  "data": [
    {
      "address": "https://www.baidu.com",
      "description": "sda",
      "id": "1",
      "logo": "图片url1",
      "name": "sda"
    },
    {
      "address": "https://www.qq.com",
      "description": "dada",
      "id": "2",
      "logo": "图片url2",
      "name": "sda"
    }
  ],
  "msg": "操作成功"
}
```
## 代码实现
```java
@Override  
public ResponseResult getAllLink() {  
    //查询所有审核通过的友链  
    LambdaQueryWrapper<Link> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Link::getStatus, SystemCanstants.LINK_STATUS_NORMAL);  
    List<Link> links = list(queryWrapper);  
    //转换vo  
    List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(links, LinkVo.class);  
    return ResponseResult.okResult(linkVos);  
}
```
